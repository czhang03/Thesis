\chapter{Domain Reasoning In TopKAT}
\label{chapter:TopKAT}
\thispagestyle{myheadings}

\section{Overview}

% 1 - Program logics are a fundamental tool for program reasoning
% 2 - Hoare logic have guided the development of formal reasoning frameworks
% 3 - KAT subsumes Hoare Logic
% 4 - Incorrectness Logic is a new deductive logic for reasoning about programs
% 5 - Can we encode Incorrectness Logic in KAT
% 6 - We show that this is not possible
% 7 - We consider TopKat and show that we can encode incorrectness triples in it
% 8 - We consider Fail top kat for reasoning about failure
% 9 - We study the relation among different models. 

Since the seminal work of \citet{Floyd67} and \citet{Hoare69}, logic has become
an essential tool for program verification.  A program logic provides a system
of \emph{deduction rules} to prove \emph{Hoare triples} \(\hoareTriple{b}{p}{c}\),
where \(p\) is a program, and \(b\) and \(c\) are assertions describing the pre-
and post-conditions.  Such Hoare triples are (partial) correctness
specifications, which state that, if we run \(p\) on an initial state satisfying
\(b\), all the final states (if reached) will satisfy \(c\). In other words, \(c\)
\emph{over-approximates} the set of final states of \(p\) starting from \(b\).

Despite their popularity, such logics are not the only tool for verifying
programs. Another long-standing approach, which can be traced back to works by
\citet{Taylor79} and \citet{odonnell_1985} in the 80s, is
\emph{equational reasoning}. Programs are modeled as elements of some algebraic
structure, whose equational theory can be used to prove specifications. One such
algebraic structure is \emph{Kleene algebra with tests}~\cite{Kozen_1997}
(KAT), which extends Kleene algebra with predicates for modeling
conditionals. Kleene algebras with tests have several pleasing properties, such
as equality of expressions being decidable in PSPACE, and have been applied in several
domains, including program transformations~\cite{Angus_Kozen_2001}, 
networking~\cite{Anderson_Foster_Guha_Jeannin_Kozen_Schlesinger_Walker_2014,Foster_Kozen_Milano_Silva_Thompson_2015,Smolka_Kumar_Foster_Kozen_Silva,Smolka_Kumar_Kahn_Foster_Hsu_Kozen_Silva_2019}, 
compiler optimization~\cite{Kozen_Patron_2000}, and more.

The two approaches turned out to be not so different. \citet{Kozen_2000}
showed that KAT can express the validity of a Hoare triple as an equation, in
such a way that the deduction rules of a large fragment of Hoare Logic can be
obtained by equational reasoning.  \citeauthor{Kozen_2000}'s work
established a clear bridge between deductive and equational reasoning for
program verification, thus shedding light on the expressive power of KAT\@.

In this work, we are interested in extending this correspondence to other
deductive formalisms for reasoning about programs.  One such formalism is
\emph{incorrectness logic} (IL), a recent proposal
by~\citet{OHearn_2020} that relates to earlier works
by~\citet{devries_ReverseHoareLogic_2011}. 
Instead of correctness, as in the Floyd-Hoare tradition, the system
revolves around \emph{incorrectness specifications} of the form
\(\incorTriple{b}{p}{c}\), which state that \(p\) can produce \emph{any} final
state satisfying \(c\) from \emph{some} input state satisfying \(b\)---or,
equivalently, that \(c\) \emph{under-approximates} the set of final states of
\(p\) starting from \(b\).  Though less conventional than traditional Hoare
logic, incorrectness logic has already found its way to several applications,
such as variants of separation logic~\cite{Raad_Berdine_Dang_Dreyer_OHearn_Villard_2020} 
and relational verification for noninterference~\cite{murray_UnderApproximateRelationalLogic_2020a}.

\begin{figure}
    \centering
    \begin{tikzcd}[row sep=5em, column sep=10em, math mode = false]
        \FailTopREL \arrow[r, two heads, 
            "\Cref{the: FailTopKAT can express incorrectness logic}"]
        & \text{IL} \\
        \TopREL \arrow[r, two heads, 
            "\Cref{the: topkat can express incorrectness logic normal termination}"]
        & \text{codomain inclusion} 
            \arrow[d, "defines"description]
            \arrow[dd, bend left=90, "defines"description]\\
        \TopGREL \arrow[d, leftrightarrow, "\Cref{the: TopGREL expressive power} (equiexpressive)"' ]
            \arrow[r, "/" marking, two heads, "\Cref{the: TopGREL expressive power}"]
        &  \text{IL (without errors)} \\
        \REL \arrow[r, two heads, "\cite{Kozen_2000}"']
            \arrow[ur, "/" marking, two heads, "\Cref{the: KAT not able to express incorrectness logic}"']
        & \text{HL} 
    \end{tikzcd}
    \caption{Expressiveness of different systems.}\label{fig:expressiveness-of-different-kat}
\end{figure}

It is natural to wonder whether \citeauthor{Kozen_2000}'s idea could be
adapted to encode incorrectness logic in Kleene algebra with tests.
Unfortunately, this is not the case. As we will show in this paper, there are
incorrectness triples that cannot be expressed by any KAT equation.  This might
appear surprising, given the symmetry between over- and under-approximation in
the formulation of Hoare logic and incorrectness logic.  However, the symmetry
involves the \emph{image} of a set by a relation, an operation that is not part
of the syntax of KAT\@.  Several prior works have considered enlarging KAT with
similar
operations~\cite{Desharnais_M√∂ller_Struth_2004,Fahrenberg_Johansen_Struth_Ziemi√°nski_2021,Desharnais_M√∂ller_Struth_2006},
but we show here that a smaller extension also serves our purposes: namely,
adding a top element \(\top\) to KAT\@.   We call such a structure a \emph{Kleene
  algebra with tests and top}, or a TopKAT\@.  We show that such structures can
encode inequalities between images, which we use to express incorrectness
triples.  The encoding allows us to prove the rules of incorrectness logic
equationally, thus extending \citeauthor{Kozen_2000}'s correspondence to
incorrectness reasoning. In fact, the use of TopKAT to encode incorrectness logic was also suggested by~\citet{OHearn_2020}.

For clarity of exposition, our main focus is on the fragment of incorrectness
logic that handles normal program termination.  However,
\citet{OHearn_2020} also considered triples of the form
\([p]\, c\, [er: q]\), whose interpretation is similar to the one we described
above, except that they assume that execution can terminate with a fatal error
(e.g.\ a failed assertion).  Following \citet{Mamouras_2017}, we show
that our encoding carries over to such triples by considering FailTopKAT, an
extension of TopKAT that includes an element \(\fail\) for representing failure.
We prove that the abnormal termination rules of incorrectness logic follow from
the equations of FailTopKAT\@.

We summarize our encodings in \Cref{fig:expressiveness-of-different-kat}.  We
use the notation \(A ‚Ü† B\) to mean that the logic \(B\) can be
expressed in the equational theory of \(A\).  More formally, we model the
ground-truth notion of validity in each logic as a statement about sets
(assertions about program states) and relations (the input-output graph of a
program).  The encodings show that such statements are equivalent to equations
involving operations in \emph{relational} algebraic structures, where the
carrier of the structure is some set of relations between program states (for
example, \(\FailTopREL\) is the class of relational FailTopKATs in
\Cref{def:relational-failtopkat}).  Moreover, we prove that the equational
theory alone (i.e., not specialized to relations) suffices to derive the rules
of each logic.  We also use the arrow \(\to\) to denote the fact that 
systems capable of expressing codomain can express both Hoare logic and incorrectness logic.

\aaa{The explanation about the \(\to\) notation in
  \Cref{fig:expressiveness-of-different-kat} seems a bit ad hoc.}

\begin{figure}
    \centering
    \begin{tikzcd}[math mode = false, row sep=4em, column sep=9em]
        & \TopREL \arrow[d, "/" marking, "incomplete"'near start, 
        "\Cref{the: topkatstar incomplete over relational model}"near start]
        & \\
        \TopGREL \arrow[r, "complete", "\Cref{the: general relational TopKAT for free}"']
        & \TopKAT & 
        \text{language \TopKAT} \arrow[l, "complete"', "\Cref{the: language TopKAT for free}"] \\
        \REL \arrow[r, "complete", "\cite{Kozen_1997}"'] & 
        \KAT & 
        \text{language \KAT} \arrow[l, "complete"', "\cite{Kozen_1997}"]
    \end{tikzcd}
    \caption{Completeness relationships between classes of Kleene Algebras with Tests.}\label{fig:completeness}
\end{figure}

To evaluate the usefulness of these encodings, we investigate two basic
properties of TopKAT\@: \emph{completeness} and \emph{decidability}.  We say
that an equational theory is complete for a certain class of structures if it
can derive any equation that is valid in the class.  We are particularly
interested in completeness with respect to relational structures, since they are
the natural setting for formulating program logics. However, it is well-known that the
addition of a top element can be problematic for completeness of relational 
structures~\cite{pousAutomataRelationAlgebra2016}, 
and we show that this is the case for TopKAT as well: the theory is incomplete for
\(\TopREL\), the class of relational structures where the top element is the
complete relation.  However, we do get completeness by considering a larger
class \(\TopGREL\), where the top element might not be the complete relation.
We also show that TopKAT is complete for so-called \emph{language TopKATs}, a
class of structures inspired by prior work on KAT\@.
(Figure~\ref{fig:completeness} summarizes the relationships between these
different structures.)  Finally, we show that the equality of TopKAT expressions can
be decided in PSPACE, by reducing a TopKAT expression into a KAT expression and 
applying the PSPACE algorithm for KAT equalities~\cite{Cohen_Kozen_Smith_1999}.

Summarizing, our contributions are:
\begin{itemize}
\item We show that (propositional) incorrectness logic cannot be encoded in
  relational KATs. Consequently, KAT cannot be used to reason equationally about
  incorrectness triples in general.
\item We consider TopKAT, an extension of KAT with an additional top element
  \(\top\), and show that (propositional) incorrectness logic for programs
  without error primitives can be encoded in relational TopKATs, by using \(\top\)
  to encode the codomain of a relation.  We prove that all the rules of this
  fragment of incorrectness logic can be derived solely by appealing to the
  equational theory of TopKAT\@.
\item We study the relations between the different systems we present
  in terms of expressivity and completeness.
\aaa{The phrasing sounds a bit weak. Can we relate this somehow to the original
  motivation in terms of incorrectness logic?}
\item We prove that deciding equality of TopKAT expressions is PSPACE-complete.
\item We consider FailTopKAT, an extension of TopKAT by means of an element
  \(\fail\) and we show that this can be used to encode incorrectness logic with
  an error primitive.
\end{itemize}


\section{Background}

\subsection{Hoare Logic}\label{sec:incorrectness-and-hoare}

Hoare logic is a fundamental tool for specifying and proving the correctness of
while-like programs. Following \citet{Kozen_2000}, we consider here
\emph{propositional Hoare logic}, which involves partial correctness Hoare
triples \(\hoareTriple{b}{p}{c}\) consisting of atomic propositions,
propositional connectives and while-like programs.  As usual, a Hoare triple
\(\hoareTriple{b}{p}{c}\) means that if the program \(p\) terminates when run on
a memory satisfying \(b\), it will result in a memory satisfying \(c\).
\Cref{fig:HL} shows the rules of propositional Hoare logic, which differ from
the classical setting in their omission of the assignment rule.


\begin{figure}\label{fig:HL}
    \begin{mathpar}
        \inferrule[Composition]
        {\hoareTriple{a}{p}{b} \\ \hoareTriple{b}{q}{c}}
        {\hoareTriple{a}{p;q}{c}}
    
        \and 
        \inferrule[Conditional]
        {\hoareTriple{b\land c}{p}{d} \\ \hoareTriple{\neg b\land c}{q}{d}}
        {\hoareTriple{c}{\comITE{b}{p}{q}}{d}}

        \and
        \inferrule[While]
        {\hoareTriple{b\land c}{p}{c}}
        {\hoareTriple{c}{\comWhile{b}{p}}{\neg b\land c}}

        \and
        \inferrule[Consequence]
        {b' ‚Üí b \\ \hoareTriple{b}{p}{c} \\ c ‚Üí c'}
        {\hoareTriple{b'}{p}{c'}}

      \end{mathpar}
\end{figure}

In its essence, Hoare logic is an \emph{over-approximation} logic.  To see this,
it is convenient to think about a program \(p\) as a relation between input
memories and output memories, and to think about predicates \(b\) and \(c\) as
sets of states.  Given a program \(p\) and a predicate \(b\), we can write
\(\post(p)(b)\) for the set of post-states, that is
%
\[\post(p)(b)=\{ x \mid \exists y\in b, (y,x)\in p \}.\]
%
A partial-correctness Hoare triple \(\hoareTriple{b}{p}{c}\) is valid
iff \[\post(p)(b) \subseteq c.\] In words, \(c\) over-approximates the set of
memories which can be obtained from \(b\) by running the program \(p\).  This
condition can be expressed by means of the codomain of a relation: if we set
\[\cod(r) ‚âú \{y \mid \exists x \in X, (x, y) \in r\},\]
then, for all a relational KAT \((‚Ñõ, ‚Ñ¨)\), 
\(b, c \in ‚Ñ¨\) and \(p \in ‚Ñõ\),
\[\hoareTriple{b}{p}{c} ‚âú \cod(b p) \subseteq \cod(c).\]


\citet{Kozen_2000} showed that we can reason about the 
partial correctness of propositional Hoare logic in KAT\@. 
To do this  we can use tests to represent pre and post-conditions,
thus encode a partial correctness propositional Hoare triple
\(\hoareTriple{b}{p}{c}\) as the KAT equality:
\[b p \overline{c} = 0\]
or equivalently \[b p = b p c.\]

Indeed, we can show that in all relational KATs \((‚Ñõ, ‚Ñ¨)\) and
\(p \in ‚Ñõ, b, c \in ‚Ñ¨\),
\[\hoareTriple{b}{p}{c} \iff bp = bpc \iff b p \overline{c} = 0.\]
Given that KAT is complete over relational KAT, we can determine the relational
validity of some propositional Hoare triples by the equational theory of KAT\@.

\subsection{Incorrectness Logic}
% The formulation provided by \citet{Kozen_2000} turns out to be very useful 
% in reasoning about program correctness using equational theory of KAT;
% but what if the given program is incorrect? 
%
\citet{OHearn_2020} proposed incorrectness logic to reason about
incorrect programs.  This logic is also related to earlier works by
\citet{devries_ReverseHoareLogic_2011}.  Like Hoare logic, incorrectness logic is built on
triples of the form \(\incorTriple{b}{p}{c}\), which denote \emph{incorrectness
  specifications}, where \(c\) is a set of undesirable final states and \(b\) is a
precondition. Intuitively, such a triple says that every memory in \(c\) needs
to be reachable from \(b\) by executing \(p\).

\begin{figure}
    \begin{mathpar}
        \inferrule[Empty]
        {\\}{\incorTriple{b}{p}{\epsilon: ‚ä•}}

        \and
        \inferrule[Consequence]
        {b ‚Üí b' \\ \incorTriple{b}{p}{\epsilon: c} \\ c' ‚Üí c}
        {\incorTriple{b'}{p}{\epsilon: c'}}

        \and
        \inferrule[Disjunction]
        {\incorTriple{b_1}{p}{\epsilon: c_1} \\ \incorTriple{b_2}{p}{\epsilon: c_2}}
        {\incorTriple{b_1 \lor b_2}{p}{\epsilon: (c_1 \lor c_2)}}

        \and
        \inferrule[Identity]
        {\\} {\incorTriple{b}{\comSkip}{\okState: b, \errState: 0}}

        \and
        \inferrule[Composition-Fail]
        {\incorTriple{a}{p}{\errState: b}}
        {\incorTriple{a}{p;q}{\errState: b}}

        \and
        \inferrule[Composition-Normal]
        {\incorTriple{a}{p}{\okState: b} \\ \incorTriple{b}{p}{\epsilon: c}}
        {\incorTriple{a}{p;q}{\epsilon: c}}

        \and
        \inferrule[Choice-Left]
        {\incorTriple{b}{p}{\epsilon: c}}
        {\incorTriple{b}{p + q}{\epsilon: c}}

        \and
        \inferrule[Choice-Right]
        {\incorTriple{b}{q}{\epsilon: c}}
        {\incorTriple{b}{p + q}{\epsilon: c}}

        \and
        \inferrule[Assume]
        {\\}
        {\incorTriple{a}{\comAssume{b}}{\okState: a \land b, \errState: 0}}

        \and
        \inferrule[Error]
        {\\}{\incorTriple{b}{\fail}{\errState: b}}

        \and
        \inferrule[Iter-Zero]
        {\\}{\incorTriple{b}{{p}^*}{\okState: b}}

        \and
        \inferrule[Iter-NonZero]
        {\incorTriple{b}{{p}^*;p}{\epsilon: c}}
        {\incorTriple{b}{{p}^*}{\epsilon: c}}

        \and
        \inferrule[Iter-Dependent]
        {‚àÄ n ‚àà ‚Ñï,~ \incorTriple{b(n)}{p}{\okState: b(n+1)}}
        {\incorTriple{b(0)}{{p}^*}{\okState: \exists n, b(n)}}
    \end{mathpar}
    \caption{Generic incorrectness logic proof rules~\cite{OHearn_2020}}\label{fig: orignal proof rules of inc logic}
\end{figure}

If Hoare logic is an ``over-approximation'' logic, incorrectness logic is an
``under-approximation'' logic: an incorrectness triple \(\incorTriple{b}{p}{c}\)
is valid if and only if
\[\post(p)(b) \supseteq c.\]

In other words, the post-condition \(c\) ``under-approximates'' the canonical
post condition of \(b\) after executing \(p\).
When we only look at program that terminates normally, 
the previous definition can be expressed in relational KAT as 
\[\cod(bp) \supseteq \cod(c).\]
As mentioned by \citet{OHearn_2020},
the definitions of incorrectness and Hoare triples are highly symmetric:
\begin{align*}
    \hoareTriple{b}{p}{c} & ‚âú \cod(b p) ‚äÜ \cod(c) \\
    \incorTriple{b}{p}{c} & ‚âú \cod(b p) ‚äá \cod(c)
\end{align*}

Since incorrect programs often lead to explicit errors,
\citet{OHearn_2020} also considered incorrectness triples
\(\incorTriple{b}{p}{\errState: c}\), which mean that, in addition to satisfying
$c$, we require that the final states of $p$ lead to an error.  More generally,
we use the notation $\incorTriple{b}{p}{\epsilon: c}$, where the \emph{error
  code} \(\epsilon \in \{\okState, \errState\}\) signals whether the program
terminated normally or not; hence, the unqualified notation
\(\incorTriple{b}{p}{c}\) is simply a shorthand for
\(\incorTriple{b}{p}{\okState: c}\), when abnormal termination is not a
concern. Informally, such general triples mean that
\[\incorTriple{b}{p}{\epsilon: c} ‚âú \cod(b p) \supseteq \cod((\epsilon: c)).\]
In \Cref{sec: failkat and error}, we will give a more concrete definition of
this semantics in an extension of KAT\@.

The generic proof rules of incorrectness logic are listed in \Cref{fig: orignal
  proof rules of inc logic}.
Following \citet{OHearn_2020}, we formulate
incorrectness logic for a language of commands which is essentially
the same of KAT terms. Conditionals and loops can be encoded with an
encoding that is similar to the one given by
\citet{Kozen_1997}.
\begin{align*}
    \comITE{b}{p}{q} & ‚âú  (\comAssume{b};p) + (\comAssume{\overline{b}}; q) \\
    \comWhile{b}{p} & ‚âú {(\comAssume{b}^*; p)} ;\comAssume{\overline{b}}
\end{align*}
Following \citet{OHearn_2020}
we also use
\(\incorTriple{b}{p}{\okState: c_1, \errState: c_2}\) as a shorthand for two
different rules. For example, the rule
\begin{mathpar}
    \inferrule[Unit]
    {\\}{\incorTriple{a}{1}{\okState: a, \errState: 0}}
\end{mathpar}
stands for the two rules
\begin{mathpar}
    \inferrule[Unit-Ok]
    {\\}{\incorTriple{a}{1}{\okState: a}}

    \inferrule[Unit-Er]
    {\\}{\incorTriple{a}{1}{\errState: 0}}.
  \end{mathpar}
The fragment of incorrectness logic we consider here is \emph{propositional} in the sense of \citet{Kozen_2000}. In particular, this presentation omits  rules for variables and mutation~\cite{OHearn_2020}. 

\section{Formulating Incorrectness Logic}\label{sec: formulating incorrectness logic}

We might hope that the symmetry between Hoare logic and incorrectness logic
would help us express incorrectness triples by adapting the formulation of
\citet{Kozen_2000}. However,
it is not obvious how we can exploit this symmetry, since it involves the
codomain operation, which does not appear in the formulation of
\citet{Kozen_2000}.  
This difficulty, unfortunately, is fundamental: KAT cannot express
incorrectness logic.

\begin{definition}\label{def: relational validity of incorrectness triple}
  Given a relational KAT \((‚Ñõ, ‚Ñ¨)\), \(p \in ‚Ñõ\)
  and \(b, c \in ‚Ñ¨\), an Incorrectness Triple
  \(\incorTriple{b}{p}{c}\) is \emph{valid} with respect to
  \((‚Ñõ, ‚Ñ¨)\), denoted
  \((‚Ñõ, ‚Ñ¨) \models \incorTriple{b}{p}{c}\), if
  \[\cod(bp) \supseteq \cod(c)\]
  we consider the predicate of incorrectness triple:
  \(inc(b, p, c) ‚âú \incorTriple{b}{p}{c}\).  We write \(inc\) over
  primitive tests \(b, c\) and primitive action \(p\) as
  \(\incorTriple{b}{p}{c}\).
\end{definition}

To show that incorrectness triple cannot be formulated using equality of KAT
terms, we only need to show that \(\incorTriple{b}{p}{c}\)
cannot be expressed in \(\REL\).  More explicitly, we need to show that for
all \(K, B\) where \(p ‚àà K\) and \(b, c ‚àà B\), there
does \emph{not} exist a pair of terms
\(e‚ÇÅ, e‚ÇÇ ‚àà \KAT_{K, B}\) s.t.\ for all relational
Interpretation \(I\):
\[I(e‚ÇÅ) = I(e‚ÇÇ) ‚ü∫ \incorTriple{I(b)}{I(p)}{I(c)}\] 


\begin{theorem}\label{the: KAT not able to express incorrectness logic}
    \(\incorTriple{b}{p}{c}\)
    cannot be expressed in \(\REL\).
\end{theorem}

\begin{proof}
    First, by \Cref{the: redundancy of alphabet},
    we only need to show that there does not exist
    \[e‚ÇÅ, {e‚ÇÇ} ‚àà \KAT_{\{p\},\{b, c\}}\]
    that can express incorrectness logic.

    Let's assume that there exist \({e‚ÇÅ}\) and \({e‚ÇÇ}\) 
    in \(\KAT_{\{p\},\{b, c\}}\)
    such that
    \[I(e‚ÇÅ) = I(e‚ÇÇ) ‚ü∫ \incorTriple{I(b)}{I(p)}{I(c)}\]  holds for all relational interpretation \(I\).

    Consider the relational KAT \(‚Ñõ\) 
    that contains all the relations and predicates over \(\{0, 1\}\).
    We will construct a pair of interpretation on \(b, c, p\) 
    to show a contradiction: 
    \begin{align*}
        I_{\emptyset}(p) & ‚âú ‚àÖ 
        & I(p) & ‚âú \{(0, 1)\} \\
        I_{\emptyset}(b) & ‚âú \{(0, 0)\}
        & I(b) & ‚âú \{(0, 0)\} \\
        I_{\emptyset}(c) & ‚âú \{(1, 1)\}
        & I(c) & ‚âú \{(1, 1)\}.
    \end{align*}
    Where the incorrectness triple
    \(\incorTriple{b}{p}{c}\) is valid with interpretation
    \(I\), but not with \(I_{\emptyset}\).  And the only difference between
    \(I\) and \(I_{\emptyset}\) is that \(p\) is mapped to \(\emptyset\)
    in \(I_{\emptyset}\).

    Since \(I_{\emptyset}\) valuates the only action variable \(p\) as \(\emptyset\),
    By \Cref{the: only one action var} 
    all the elements of \(I_‚àÖ(e‚ÇÅ)\) must be of the form \((x, x)\).
    Then because the incorrectness triple \(\incorTriple{b}{p}{c}\)
    is invalid with \(u_{\emptyset}\),
    \[I_‚àÖ(e‚ÇÅ) \neq I_‚àÖ(e‚ÇÇ).\]
    Without loss of generality, assume that
    \((x, x) ‚àà I_‚àÖ(e‚ÇÅ)\), but not in
    \(I_‚àÖ(e‚ÇÇ)\).  Then by monotonicity of
    interpretation (\Cref{the: monotonicity of relational interpretation}),
    \((x, x) ‚àà I(e‚ÇÅ)\).  We will derive a contradiction
    from the fact that \((x, x) ‚àà I(e‚ÇÇ)\) but
    \((x, x) ‚àà I_‚àÖ(e‚ÇÇ)\).  We can summarize the
    above strategy using \Cref{fig: proof of KAT cannot encode IL}.

    Because \((x, x) ‚àâ I_‚àÖ(e‚ÇÇ)\)
    and the only element of the action \(u(p)\) is \((1, 0)\),
    none of the conditions in \Cref{the: KAT inccorrectness logic core lemma} is satisfied,
    therefore \((x, x)\) cannot be in \(I(e‚ÇÇ)\),
    which contradicts the earlier result stating \((x, x) \in I(e‚ÇÇ)\).
\end{proof}

\begin{figure}
    \centering
    \begin{tikzcd}[row sep=1.5em, column sep=1.5em]
        (x, x) \in I(e‚ÇÅ)
            \arrow[rrr, "I(e‚ÇÅ) = I(e‚ÇÇ)"] 
            &&& 
        (x, x) \in I(e‚ÇÇ) \\
        & I(e‚ÇÅ) 
            \arrow[r, equal]
        & I(e‚ÇÇ) & \\
        & I_‚àÖ(e‚ÇÅ) 
            \arrow[u, hook, "\text{monotonicity}"]
            \arrow[r, equal, "/" marking]
        & I_‚àÖ(e‚ÇÇ) 
            \arrow[u, hook, "\text{monotonicity}"']
        & \\
        (x, x) ‚àà I_‚àÖ(e‚ÇÅ) 
            \arrow[uuu, "\text{by monotonicity}"] &&& 
        (x, x) ‚àâ I_‚àÖ(e‚ÇÇ) 
            \arrow[uuu, dash, "\text{contradiction}"', "√ó"marking]\\
    \end{tikzcd}
    \caption{Relation of interpretations \(I\) and \(I_{\emptyset}\)}\label{fig: proof of KAT cannot encode IL}
\end{figure}

One strategy for exploiting the symmetry between Hoare and incorrectness logic
is to extend KAT with a codomain operator.  Similar ideas have been explored in prior work~\cite{fitzgerald_modal_2016,Fahrenberg_Johansen_Struth_Ziemi√°nski_2021,desharnais_modal_2004}. However,
rather than adopting a full-fledged codomain operator, it suffices for our
purposes to consider a equational theory that only extends KAT with a top
element.  Such an algebraic structure has also been considered in prior
work~\cite[Section~4]{Mamouras_2017}, though for a different purpose.

\begin{definition}[KAT with a Top Element]
  A KAT with top, or TopKAT, is a KAT \(ùí¶\) that contains a largest
  element \(\top\); that is, for all elements \(p \in ùí¶\),
  \[\top \geq p.\]
  A relational TopKAT over \(X\) is a relational KAT 
  where the top element is the complete relation \(X \times X\).
\end{definition}

\begin{theorem}[TopKAT can Express Codomain]\label{the: top element can express domain}
    For all relational TopKATs \(‚Ñõ\),
    and \(p, q \in ‚Ñõ\) The following is true:
    \[\top p = \top q \iff \cod(p) = \cod(q)\]
    and 
    \[\top p \leq \top q \iff \cod(p) \subseteq \cod(q).\]
\end{theorem}

\begin{proof}
  For all relations \(r \subseteq X \times X\):
    \begin{align*}
        \top ‚ãÖ r 
        & = \{(z, y) \mid z \in X \land \exists x, (x, y) \in r\} 
        = \{(z, y) \mid z \in X \land y \in \cod(r)\} 
    \end{align*}
    Therefore for two relation \(p, q\), we will have 
    \begin{align*}
        ‚ä§ ‚ãÖ q = ‚ä§ ‚ãÖ p & ‚ü∫ 
        \{(z, y) ‚à£ z ‚àà X ‚àß y ‚àà \cod(q)\}
        = \{(z, y) ‚à£ z ‚àà X ‚àß y ‚àà \cod(p)\} \\
        & ‚ü∫ \cod(q) = \cod(p) \\
        ‚ä§ ‚ãÖ q ‚â§ ‚ä§ ‚ãÖ p & ‚ü∫ 
        \{(z, y) ‚à£ z ‚àà X ‚àß y ‚àà \cod(q)\}
        \subseteq \{(z, y) \mid z \in X \land y \in \cod(p)\} \\
        & \iff \cod(q) \subseteq \cod(p) 
    \end{align*} 
\end{proof}


\begin{corollary}\label{the: topkat can express incorrectness logic normal termination}
    For all relational TopKATs \((‚Ñõ, ‚Ñ¨)\),
    and \(p ‚àà ‚Ñõ\), \(b, c \in ‚Ñ¨\)
    we have the following:
    \[{‚ä§ bp ‚â• ‚ä§ c} ‚ü∫ {\incorTriple{b}{p}{c}}\]
\end{corollary}

Notice that the left hand side of this equivalence makes sense in all TopKATs,
not just relational ones.
Thus it is natural to generalize the definition of incorrectness triple to all TopKATs
using the inequality \(\top bp \geq \top c\).
As a matter of fact, just by using the equational theory of TopKAT,
we can find several equivalent formulations of incorrectness triple:

\begin{theorem}[Equivalent Formulation of Incorrectness Logic]
  Given a TopKAT \((ùí¶, ‚Ñ¨)\), where \(p \in ùí¶\) and
  \(b, c \in ‚Ñ¨\), we say that an incorrectness triple
  \(\incorTriple{b}{p}{c}\) is valid if the following equivalent conditions are
  met:
  \[‚ä§ b p ‚â• ‚ä§ c ‚ü∫ ‚ä§ b p ‚â• c ‚ü∫ ‚ä§ b p c = ‚ä§ c\]
\end{theorem}

\begin{proof}
We show that these conditions are equivalent in all TopKATs.
\begin{itemize}
    \item First show \[\top b p \geq \top c \iff \top b p \geq c,\]
    the \(\implies\) is true because \(\top \geq 1\):
    \[\top b p \geq \top c \geq c,\]
    the \(\impliedby\) can be proven by idempotency of \(\top\):
    \[\top b p = \top \top b p \geq \top c.\]
    \item Then show \[\top b p \geq \top c \iff \top b p c = \top c,\]
    the \(\impliedby\) can be shown by \(1 \geq c\):
    \[\top b p \geq \top b p c = \top c,\]
    the \(\implies\) is by two inequalities:
    \begin{align*}
        \top b p \leq \top & \implies \top b p c \leq \top c \\
        c \leq 1 \land \top b p \geq \top b p c & \implies \top b p \geq \top b p c = \top c.\\
    \end{align*}
    Therefore we have our conclusion \(\top b p c = \top c\).
\end{itemize}
\end{proof}

A similar encoding involving \(\top\) was also mentioned by \citet{OHearn_2020}.

We want to show that this abstraction is enough to capture all the rules of
incorrectness logic.  Indeed most of the the rules are formulated using program
operations expressible in \(\KAT\) ~\cite{OHearn_2020}.  We
focus here on the proof rules concerning normal program termination, and we will
further investigate the rules with error in \Cref{sec: failkat and error}.


\begin{figure}
    \begin{mathpar}
        \inferrule[Empty]
        {\\}{\incorTriple{b}{p}{0}}
    
        \and
        \inferrule[Consequence]
        {b \leq b' \\ \incorTriple{b}{p}{c} \\ c' \leq c}
        {\incorTriple{b'}{p}{c'}}
    
        \and 
        \inferrule[Disjunction]
        {\incorTriple{b_1}{p}{c_1} \\ \incorTriple{b_2}{p}{c_2}}
        {\incorTriple{b_1 + b_2}{p}{c_1 + c_2}}
    
        \and 
        \inferrule[Identity]
        {\\} {\incorTriple{b}{1}{b}}
    
        \and 
        \inferrule[Composition]
        {\incorTriple{a}{p}{b} \\ \incorTriple{b}{q}{c}}
        {\incorTriple{a}{pq}{c}}
    
        \and 
        \inferrule[Choice-Left]
        {\incorTriple{a}{p}{b} }
        {\incorTriple{a}{p + q}{b}}
    
        \and 
        \inferrule[Choice-Right]
        {\incorTriple{a}{q}{b} }
        {\incorTriple{a}{p + q}{b}}
    
        \and 
        \inferrule[Assume]
        {\\}
        {\incorTriple{b}{c}{bc}}
    
        \and 
        \inferrule[Iter-Zero]
        {\\}{\incorTriple{b}{\comIter{p}}{b}}
    
        \and 
        \inferrule[Iter-NonZero]
        {\incorTriple{b}{\comIter{p}p}{c}}{\incorTriple{b}{\comIter{p}}{c}}
    
        \and
        \inferrule[Iter-Dependent]
        {\forall n \in ‚Ñï, \incorTriple{b_n}{p}{b_{n + 1}}}
        {\incorTriple{b_0}{\comIter{p}}{\sup_{n \in ‚Ñï} b_{n}}}
    \end{mathpar}
    \caption{Incorrectness logic with normal termination}\label{fig: normal terminating Inc rule}
\end{figure}

In \Cref{fig: normal terminating Inc rule}, we present all the rules of
incorrectness logic with normal termination using the syntax of KAT.  (Note
that this differs slightly from \citeauthor{OHearn_2020}'s
original notation; for instance, the sequencing operator \(p;q\) corresponds to
multiplication \(pq\) in KAT, and the logical implication \(b ‚Üí b'\)
corresponds to order \(b \leq b'\).)  For the Iter-dependent rule (Backwards
Variant in~\cite{OHearn_2020}), the function \(b(n)\) corresponds
to a sequence of tests \((b_n)_{n \in ‚Ñï}\), and the existential
\(\exists n, b(n)\) corresponds to the infinite disjunction of all these
\(b_n\), which we express as \(\sup_{n \in ‚Ñï} b_n\).  (Note that \(\sup\)
does not exist in KATs, TopKATs, or boolean algebras in general, and this rule
implicitly assumes that \(\sup_{n \in ‚Ñï} b(n)\) exists.)

\begin{theorem}[Soundness of \(\okState\) State Rules]\label{the: incor logic rule sound ok}
    All the rules of \Cref{fig: normal terminating Inc rule}
    are derivable in all TopKATs.
\end{theorem}

\begin{proof}
    The proofs of each individual rules as follows:
    \begin{itemize}
        \item \textbf{Empty Rule:}
            because 0 is the smallest element 
        \item \textbf{Consequence Rule:}
            because multiplication preserves order
            and \(b' \geq b\), therefore \(\top b' p \geq \top b p\).
            Therefore 
            \[\top b' p \geq \top b p \geq c \geq c'\] 
        \item \textbf{Disjunction Rule:}
            because addition preserves order, therefore 
            \[\top b_1 p + \top b_2 p \geq c_1 + c_2\]
            and by distributivity, we have 
            \[\top (b_1 + b_2) p \geq c_1 + c_2\]
        \item \textbf{Identity Rule:}
            because \(\top \geq 1\),
            therefore \[\top b 1 \geq 1 b 1 \geq b\]
        \item \textbf{Composition Rule:}
            first, by idempotency of \(\top\)
            and associativity of multiplication, we have 
            \[\top a (p q) = \top \top a p q\]
            By order preserving of multiplication, 
            and \(\top a p \geq b\),
            we have \[\top a (p q) = \top \top a p q \geq \top b q \geq c\]
        \item \textbf{Choice Left and Choice Right Rule:}
            by distributivity, we have 
            \[\top b (p + q) 
            = \top b p + \top b q 
            \geq \top b p \geq c\]
            and 
            \[\top b (p + q) 
            = \top b p + \top b q 
            \geq \top b q \geq c\]
        \item \textbf{Assume Rule:}
            since \(\top \geq 1\), 
            we have \[\top b c = \top b c \geq 1 b c = bc\]
        \item \textbf{Iter-Zero Rule:}
            since \({p}^* = p {p}^* + 1\),
            we have 
            \[\top b {p}^* 
            = \top b (p {p}^* + 1)
            \geq \top b 1 \geq b\]
        \item \textbf{Iter-NonZero Rule:}
            since \({p}^* = p {p}^* + 1\),
            we have 
            \[\top b {p}^* 
            = \top b (p {p}^* + 1)
            \geq \top b p {p}^* \geq c\]
        \item \textbf{Iter-Dependent Rule:}
            by definition of \(\sup\),
            in order to show \(\top b_{0} {p}^* \geq \sup_{n \in ‚Ñï} b_{n}\)
            all we need to show is that for all \(m \in ‚Ñï\)
            \(\top b_{0} {p}^* \geq b_{m}\).
            We prove this by induction on \(m\).
            \begin{itemize}
                \item \textbf{Base Case:}
                    we need to show \(\top b_{0} {p}^* \geq b_{0}\).
                    Because \({p}^* = 1 + p{p}^*\),
                    therefore 
                    \[\top b_{0} {p}^* 
                    = \top b_{0} (1 + p{p}^*)
                    \geq \top b_{0} 1 \geq 1 b_{0} 1 = b_{0}\]
                \item \textbf{Inductive Case:}
                    if \(\top b_{0} {p}^* \geq b_{n}\),
                    we need to show \(\top b_{0} {p}^* \geq b_{n+1}\).
                    By premise we have \(\top b_{n} p \geq b_{n + 1}\)
                    Therefore by idempotency of the top element,
                    we have 
                    \begin{align*}
                        \top b_{0} {p}^* 
                        & = \top \top b_{0} (1 + {p}^* p) \\
                        & \geq \top \top b_{0} {p}^* p
                        & 1 + {p}^* p \geq {p}^* \\
                        & \geq \top b_{n} p
                        & \text{by induction hypothesis} \\
                        & \geq b_{n+1}
                        & \text{by premise}
                    \end{align*}
            \end{itemize}   
    \end{itemize}
\end{proof}

\paragraph*{An alternative encoding for Hoare logic}

Since \(\TopKAT\) can express codomain (\Cref{the: top element can express
  domain}), we can exploit the symmetry between incorrectness logic and Hoare
logic (\Cref{sec:incorrectness-and-hoare}) to give another encoding of Hoare
logic in \(\TopKAT\): \[\top b p \leq \top c.\] This is equivalent to the
original encoding $bp = bpc$ proposed for KATs~\cite{Kozen_2000} in \emph{all TopKAT},
not just relational ones.  
Since the proof rules of propositional Hoare logic are sound for that
encoding~\cite[Theorem~3.1]{Kozen_2000}, they are also sound for ours.

\begin{theorem}[Equivalence of Hoare Logic Formulations]\label{the: hoare logic formulation equivalent}
  For all TopKATs \((ùí¶, ‚Ñ¨)\), and three elements
  \(p \in ùí¶\) and \(b, c \in ‚Ñ¨\), the following inequalities
  are equivalent:
    \[b p \leq \top c  \iff  \top b p \leq \top c \iff b p = b p c.\]
\end{theorem}

\begin{proof}
\begin{itemize}
    \item We first show the equivalence:
        \[b p \leq \top c  \iff  \top b p \leq \top c.\]
        \(\impliedby\) is by \(1 \leq \top\),
        thus \[b p \leq \top b p \leq \top c,\]
        and \(\implies\) is by the idempotency of \(\top\),
        multiply both side with \(\top\), we have 
        \[\top b p \leq \top \top c = \top c.\]
    \item Then we show the equivalence
        \[b p \leq \top c  \iff  b p = b p c.\]
        Start with \(\impliedby\), because \(\top \geq b p\), we have
        \[b p = b p c \leq \top c.\]
        Then \(\implies\), we start from \(b p \leq \top c\),
        we first multiply \(\overline{c}\) on both side,
        \[b p \overline{c} \leq \top c \overline{c} = \top 0 = 0,\]
        and because \(b p \overline{c} \geq 0\) (\(0\) is the smallest element),
        we have \[b p \overline{c} = 0.\]
        Finally, add \(b p c\) to both side, we have
        \[b p = b p (\overline{c} + c) = 0 + b p c = b p c.\qedhere\]
\end{itemize}
\end{proof}

\section{(In)completeness and Decidability of TopKAT}\label{sec: properties of TopKAT}


In the previous section, we have shown that the theory of TopKAT subsumes incorrectness logic. In this section, we study some of the properties of its algebraic equational theory.
%
First, we will show that TopKAT is \emph{incomplete} with respect to relational
TopKATs: there are identities that are valid for every relational TopKAT that
cannot be proven using the TopKAT identities alone. This contrasts with what
happens for KAT, which is complete for relational KATs.
%
We will then show the completeness of TopKATs with respect to a class of
\emph{language-based} TopKATs and also with respect to a more general class of
\emph{relational} TopKATs, as well as the decidability of TopKAT equalities.
Finally we will introduce the concept of equational expressiveness,
and show that the general relational TopKAT has the same expressiveness as relational KAT,
hence cannot express incorrectness logic.

\subsection{Incompleteness with Respect to Relational TopKATs}

We start with our negative result, which is the incompleteness over relational TopKATs.

\begin{theorem}\label{the: topkatstar incomplete over relational model}
  \(\TopKAT\) is incomplete over \(\TopREL\): the formulas
  \[(‚ä§ p) (‚ä§ p) = ‚ä§ p \text{ and } p ‚ä§ p ‚â• p\] 
  are valid in every relational TopKAT, but not in every TopKAT\@.
\end{theorem}

\begin{proof}
  We can show that the \((‚ä§ p) (‚ä§ p) = ‚ä§ p\) 
  holds in every relational TopKAT simply by
  unfolding the definitions.  To exhibit a TopKAT where it does not hold,
  consider the following counterexample.  We take a relational KAT over
  \(\{0,1\}\) whose largest element is
  \begin{align*}
    ‚ä§ & ‚âú \{(0,0), (1,1), (0,1)\}.
  \end{align*}
  (Note that this KAT is \emph{not} a relational TopKAT\@: the largest
  element is not the complete relation.)
  Then, by taking a valuation \(u(p) ‚âú\{(0, 1)\}\), we see that
  \begin{align*}
    I(‚ä§ p) & = \{(0, 1)\} \\
    I((‚ä§ p) (‚ä§ p)) & 
        = \{(0, 1)\} ‚ãÖ \{(0, 1)\} 
        = ‚àÖ ‚â† I(‚ä§ p)
  \end{align*}

  And the same counter example also works for 
  \(p ‚ä§ p ‚â• p\).
\end{proof}

The incompleteness result might be discouraging, since we might not be able to derive some valid theorems of incorrectness logic using TopKAT. However in
\Cref{the: incor logic rule sound ok} and \Cref{the: incorrectness logic fail rule sound}, we show that all the rules of incorrectness logic are
derivable using either the equational theory of TopKAT or FailTopKAT\@.  Thus,
our framework is at least as strong as the structural proof rules presented
by~\citet{OHearn_2020}.

\subsection{Reduction on free models}\label{sec: reduction on free models}

Our goal in this section is to construct a complete interpretation for TopKAT,
by reducing its theory to that of plain KAT.  In other words, any equation
between two TopKAT expressions is logically equivalent to another equation between a
pair of corresponding KAT terms.  While this result is not
new~\cite{Zhang_de_Amorim_Gaboardi_2022, Zhang_de_Amorim_Gaboardi_2022_POPL,
  Pous_Wagemaker_2022}, we present a more streamlined proof that hinges on the
universal properties of free KATs and TopKATs, without relying explicitly on
language models.  Similar to previous works, we obtain the
decidability of the equational theory of TopKAT as a corollary of reduction.
However, because of the new notion of reduction,
our decidability result no longer depends on the completeness of the language TopKAT.  
Moreover, our technique helps us to construct complete models and interpretations 
simply by computation, as well as simplifying proofs of other results about TopKAT.


We first note that any free KAT over an alphabet \(K, B\) is also a TopKAT,
where the largest element is \((‚àë K)^*\). This fact can be seen by
straightforward induction.

\begin{lemma}\label{the: every free KAT is a TopKAT}
    Every free KAT over alphabet \(K, B\) forms a TopKAT.
\end{lemma}

\begin{proof}
    Since \(\KAT_{K, B}\) is a KAT, we only need to show 
    the expression \((‚àë K)^*\) is the largest element of \(\KAT_{K, B}\),
    i.e. \[(‚àë K)^* ‚â• e, ‚àÄ e ‚àà \KAT_{K, B}.\] 
    The above fact can be shown by induction on \(t\);
    some algebraic manipulations below use facts in~\Cref{the: well known fact about KA}:
    \begin{itemize}
        \item \((‚àë K)^* ‚â• 1\) (by unfolding rule),
              thus \((‚àë K)^*\) is larger than \(0, 1\) and every Boolean term.
        \item \((‚àë K)^*\) is larger than \(‚àë K\),
              which is larger than every primitive action.
        \item Given two expressions \(e‚ÇÅ\) and \(e‚ÇÇ\),
              assume \((‚àë K)^*\) is larger than both.
              Because \((‚àë K)^* = (‚àë K)^* + (‚àë K)^*\)
              and addition preserves order,
              \[(‚àë K)^* = (‚àë K)^* + (‚àë K)^* ‚â• e‚ÇÅ + e‚ÇÇ\] 
        \item Given two expressions \(e‚ÇÅ\) and \(e‚ÇÇ\),
              assume \((‚àë K)^*\) is larger than both.
              Because \((‚àë K)^* = (‚àë K)^* ‚ãÖ (‚àë K)^*\)
              and multiplication preserves order, 
              \[(‚àë K)^* = (‚àë K)^* ‚ãÖ (‚àë K)^* ‚â• e‚ÇÅ ‚ãÖ e‚ÇÇ.\]
        \item Given a expression \(t\),
              if \((‚àë K)^* ‚â• t\), then \((‚àë K)^* ‚â• t^*\).
              Since \((‚àë K)^* = ((‚àë K)^*)^*\) and star preserves order:
              \[(‚àë K)^* = ((‚àë K)^*)^* ‚â• t^*. \qedhere\]
    \end{itemize}
\end{proof}

Since every free KAT is a TopKAT, every KAT interpretation
\(I : \KAT ‚Üí \mathcal{K}\) induces a sub-KAT $\Img(I) ‚äÜ ùí¶$,
and this sub-KAT happens to be a \emph{TopKAT}. Specifically, the image of $(‚àë K)^*$
in $ùí¶$ is the largest element of $\Img(I)$, and the restricted
$I : \KAT ‚Üí \Img(I)$ is a TopKAT homomorphism.

This gives us a powerful tool to construct complete TopKAT interpretations.
Since we already know that the KAT interpretations \(G: \KAT ‚Üí ùí¢\) and
\(h ‚àò G: \KAT ‚Üí \Img(h)\) are injective TopKAT homomorphisms, we can
construct complete TopKAT interpretations by \emph{composition}, 
if we can construct an injective TopKAT interpretation \(r\) of type
\(\TopKAT_{K, B} ‚Üí \KAT_{K_‚ä§, B}\):
\[\TopKAT_{K, B} \xrightarrow{r} \KAT_{K_‚ä§, B} \xrightarrow{G} ùí¢_{K_‚ä§, B},\\  
  \TopKAT_{K, B} \xrightarrow{r} \KAT_{K_‚ä§, B} \xrightarrow{G} ùí¢_{K_‚ä§, B}
  \xrightarrow{h} \Img(h).\] 

In fact, such an injective homomorphism can be obtained by lifting 
the embedding map \(K + B ‚Ü™ \KAT_{K_‚ä§, B}\):
\begin{align*}
    r   & : K + B ‚Üí \KAT_{K_‚ä§, B}             \\
    r(p) & ‚âú p.                   
\end{align*}
This homomorphism coincides with the \emph{reduction maps} of the same name in
previous works~\cite{Zhang_de_Amorim_Gaboardi_2022, Pous_Wagemaker_2023}.  More
concretely, we can picture $r$ as simply replacing the symbol \(‚ä§\) in a TopKAT
term with \((‚àë K_‚ä§)^*\), the largest element in \(\KAT_{K_‚ä§, B}\).

We will show that \(r\) is injective by constructing a left inverse for it.  
In fact, the left inverse \([-]_‚ä§\) simply interprets the \(‚ä§\) primitive in \(\KAT_{K_‚ä§, B}\)
as the largest element.
\begin{lemma}\label{the: equivalence class is the inverse of reduction}
  The map \([-]_‚ä§: \KAT_{K_‚ä§, B} ‚Üí \TopKAT_{K, B}\), where each expression is
  mapped to its corresponding equivalence class, 
  is defined by lifting the following action on the primitives:
  \begin{align*}
    [p]_‚ä§ & ‚âú p & p ‚àà K + B \\  
    [‚ä§]_‚ä§ & ‚âú ‚ä§.
  \end{align*}
  The map \([-]_‚ä§\) is a TopKAT homomorphism.
\end{lemma}

\begin{proof}
  Because this map defined by lifting on the primitives,
  it is automatically a KAT homomorphism.
  All we need to show is that \([-]_‚ä§\) preserves the top element, that is
  \([(‚àë K_‚ä§)^*]_‚ä§ = (‚àë K_‚ä§)^*\) is the largest element in \(\TopKAT_{K, B}\).

  By construction of \(\TopKAT_{K, B}\), \(‚ä§\) is the largest element in \(\TopKAT_{K, B}\). 
  Thus, to prove that \((‚àë K_‚ä§)^*\) is also the largest element in \(\TopKAT_{K, B}\),
  it suffices to prove \((‚àë K_‚ä§)^* ‚â• ‚ä§\): \[(‚àë K_‚ä§)^* ‚â• ‚àë K_‚ä§ = ‚ä§ + ‚àë K ‚â• ‚ä§. \qedhere\]
\end{proof}

\begin{theorem}[Reduction]
    \([-]_‚ä§\) is the right inverse of \(r\): \([-]_‚ä§ ‚àò r  = id_{\TopKAT_{K, B}}\).
    More explicitly for all \(t ‚àà \TopKAT_{K, B}\): \[\TopKAT_{K, B} ‚äß [r(t)]_‚ä§ = t.\]
\end{theorem}

\begin{proof}
    Since \([-]_‚ä§ ‚àò r : \TopKAT_{K, B} ‚Üí \TopKAT_{K, B}\) is a TopKAT interpretation,
    the action on the primitives uniquely determines the interpretation:
    because both \(r\) and \([-]_‚ä§\) are identity on the primitives,
    therefore \([-]_‚ä§ ‚àò r\) is the identity interpretation on \(\TopKAT_{K, B}\).
\end{proof}

The above theorem matches one of the soundness condition of reductions in 
previous works~\cite{Zhang_de_Amorim_Gaboardi_2022,Kozen_Smith_1997,Pous_Rot_Wagemaker_2021},
which was typically proven by a monolithic induction on the structure of terms.
Our approach, on the other hand, relies on establishing fine-grained 
algebraic properties, like~\cref{the: every free KAT is a TopKAT,the: equivalence class is the inverse of reduction};
then the theorem follows simply by computing the action of \([-]_‚ä§ ‚àò r\) on primitives.

Since \(r\) has a right inverse, it is indeed the injective interpretation we desired, 
and it is also a complete interpretation:
\[\TopKAT_{K, B} ‚äß e‚ÇÅ = e‚ÇÇ ‚ü∫ r(e‚ÇÅ) = r(e‚ÇÇ),\]
With the completeness of \(r\), we can already show the complexity of TopKAT.
The complexity results echos previous proofs~\cite{Zhang_de_Amorim_Gaboardi_2022,Pous_Wagemaker_2023},
but we are able to obtain this result without completeness of TopKAT language interpretation,
which is essential in previous proofs. 

\begin{corollary}[Complexity]\label{the: PSPACE-completeness of TopKAT}
  Given two expressions \(e‚ÇÅ, e‚ÇÇ ‚àà \TopKAT_{K, B}\), deciding whether these two terms
  are equal is PSPACE-complete.
\end{corollary}

\begin{proof}
    Deciding KAT equality is a sub-problem of deciding TopKAT equality,
    and KAT equality is PSPACE-hard \cite{Cohen_Kozen_Smith_1999};
    therefore TopKAT equality is PSPACE-hard.

    To decide the equality of \(e‚ÇÅ, e‚ÇÇ\),
    we first remove all the redundant primitives that do not appear in \(e‚ÇÅ, e‚ÇÇ\)
    from the alphabet \(K, B\). Then we compute \(r(e‚ÇÅ)\) and \(r(e‚ÇÇ)\),
    each taking polynomial space (of \(|e‚ÇÅ| + |e‚ÇÇ|\)) to store;
    and we use the standard algorithm \cite{Cohen_Kozen_Smith_1999}
    to decide whether \(r(e‚ÇÅ) = r(e‚ÇÇ)\) in \(\KAT_{K_‚ä§, B}\),
    this will also take polynomial space.
    Hence, the decision procedure for TopKAT equality in PSPACE.

    Thus deciding TopKAT equality is PSPACE-complete.
\end{proof}


\subsection{Computing the complete interpretations}\label{sec: complete model for free}

Designing complete interpretations and models was not always easy.
In fact, in previous works \cite{Zhang_de_Amorim_Gaboardi_2022_POPL},
the authors made a mistake in the definition of language TopKAT,
which was fixed later \cite{Zhang_de_Amorim_Gaboardi_2022} 
by suggestion of Pous et al. \cite{Pous_Wagemaker_2022}.
However, with the results in~\Cref{sec: reduction on free models},
we can construct the complete interpretation just by composition,
and compute the complete model by computing the range of the complete interpretation.

We already know that there are two complete interpretations of TopKAT defined as follows:
\[\TopKAT_{K, B} \xrightarrow{r} \KAT_{K_‚ä§, B} \xrightarrow{G} ùí¢_{K_‚ä§, B},\\  
\TopKAT_{K, B} \xrightarrow{r} \KAT_{K_‚ä§, B} \xrightarrow{G} ùí¢_{K_‚ä§, B} \xrightarrow{h} \Img(h),\]
with a complete language model \(ùí¢_{K_‚ä§, B}\), 
and a complete model consisting of relations \(\Img(h)\).

The operations in these models can be recovered by computing these maps.
For example, the multiplication operation in the language TopKAT can be computed as follows:
\[G ‚àò r(e‚ÇÅ ‚ãÖ e‚ÇÇ) = G(r(e‚ÇÅ) ‚ãÖ r(e‚ÇÇ)) = G(r(e‚ÇÅ)) ‚ãÑ G(r(e‚ÇÇ)).\]
Since \(r\) does not change the multiplication operation,
the multiplication in the language TopKAT is the same as in language KAT.
In fact, as \(r\) does not change any operation in KAT,
most operations in language TopKAT are the same as language KAT.
Thus, we only need to compute the top element in language TopKAT.

The top element in language TopKAT can be computed in the same fashion:
\[G ‚àò r(‚ä§) = G((‚àë K_‚ä§)^*) = GS_{K_‚ä§, B},\]
i.e. the top element is just the complete language.

\begin{corollary}\label{the: language TopKAT for free}
    The language TopKAT inherits all the operations in language KAT,
    except the top element, which is defined as the full language.
    And such models are complete with \(G ‚àò r\) as a complete interpretation.
\end{corollary}

In the same way, we know that complete models consisting of relations (a.k.a. general relational TopKAT) 
will have the same operations as relational KATs.
However, in this case the characterization of the computed top: \(h ‚àò G ‚àò r(‚ä§)\)
is not as simple as the full language,
but we know it is the largest relation in the range of \(h ‚àò G ‚àò r\):

\begin{corollary}\label{the: general relational TopKAT for free}
    The general relational TopKAT inherits all the operations in relational KAT,
    except the top element is the largest relation.
    And such models are complete with \(h ‚àò G ‚àò r\) as a complete interpretation.
\end{corollary}

Finally, to investigate whether we can use general relational TopKAT
to encode incorrectness logic,
we will provide a short proof that general relational TopKATs
are as expressive as relational KATs~\cite{Zhang_de_Amorim_Gaboardi_2022};
that is, every property on relations that can be encoded using general relational TopKAT,
is already encodable in the relational KAT.
Hence, adding a top element does not give extra expressive power in general relational TopKAT.

The original proof~\cite[Lemma 2]{Zhang_de_Amorim_Gaboardi_2022} 
encodes every TopKAT expression using a KAT term,
and then uses two pages to prove the soundness of this encoding.
Here we show the aforementioned encoding is simply the reduction \(r\).

\begin{definition}
    Given two expressions \(e‚ÇÅ, e‚ÇÇ ‚àà \TopKAT\), and n primitives \(p‚ÇÅ, p‚ÇÇ, ‚Ä¶ , p‚Çô ‚àà K + B\),
    we say that an n-ary predicate \(P\) is \emph{expressible} by 
    equation \(e‚ÇÅ = e‚ÇÇ\) for a class of TopKATs \(\mathsf{K}\) 
    when for all interpretations \(I\) into TopKATs in \(\mathsf{K}\),
    the following equivalence holds:
    \[I(e‚ÇÅ) = I(e‚ÇÇ) ‚ü∫ P(I(p‚ÇÅ), I(p‚ÇÇ), ‚Ä¶, I(p‚Çô)).\]
\end{definition}

\begin{theorem}[Expressiveness of general relational TopKAT]\label{the: TopGREL expressive power}
    Given an alphabet \(K, B\), an n-ary predicate \(P\) on relations,
    the predicate \(P\) over primitives \(p‚ÇÅ, p‚ÇÇ, ‚Ä¶ , p‚Çô ‚àà K\) is expressible in
    general relational TopKAT if and only if it is expressible in relational KAT.
\end{theorem}

\begin{proof}
    A predicate expressible in relational KAT is also expressible 
    in general relational TopKAT using the same pair of terms,
    we only need to show the converse.
    Assume a predicate \(P\) is expressible in general relational TopKAT,
    then there exists two TopKAT expressions \(e‚ÇÅ, e‚ÇÇ ‚àà \TopKAT_{K, B}\) s.t. 
    for all general relational TopKAT interpretations \(I_‚ä§\):
    \[I_‚ä§(e‚ÇÅ) = I_‚ä§(e‚ÇÇ) ‚ü∫ P(I_‚ä§(p‚ÇÅ), I_‚ä§(p‚ÇÇ), ‚Ä¶ , I_‚ä§(p‚Çô));\]

    We take an arbitrary relational KAT interpretation \(I\) from \(\KAT_{K_‚ä§, B}\).
    Notice \(\Img(I)\), the range of \(I\), 
    is a relational KAT with the largest element \(I((‚àë K)^*)\),
    i.e. \(\Img(I)\) is a general relational TopKAT.
    Because \(I\) is a KAT interpretation, 
    it preserves all the KAT operations and the largest element.
    Hence, \(I\) is a TopKAT homomorphism from \(\KAT_{K_‚ä§, B}\) to \(\Img(I)\).

    Then we can construct \(I ‚àò r: \TopKAT_{K, B} ‚Üí \Img(I)\),
    a general relational interpretation:
    \begin{align*}
        I(r(e‚ÇÅ)) = I(r(e‚ÇÇ))
         & ‚ü∫ I ‚àò r(e‚ÇÅ) = I ‚àò r(e‚ÇÇ)                           \\
         & ‚ü∫ P(I ‚àò r(p‚ÇÅ), ‚Ä¶ , I ‚àò r(p‚Çô))
            & \text{\(I ‚àò r\) is a \(\TopGREL\) interpretation} \\
         & ‚ü∫ P(I(p‚ÇÅ), ‚Ä¶ , I(p‚Çô))
            & r(p·µ¢) = p·µ¢
    \end{align*}
    Thus the two KAT expressions \(r(e‚ÇÅ), r(e‚ÇÇ) ‚àà \KAT_{K_‚ä§, B}\) also can express the predicate \(P\).
\end{proof}

Since the image of \(I\) is not necessarily a relational TopKAT,
where the top element is interpreted as the complete relation,
the above trick does not work for relational TopKAT.
It is also known that relational TopKAT is strictly more expressive than general relational TopKAT,
since relational TopKAT can encode incorrectness logic,
where general relational TopKAT cannot~\cite{Zhang_de_Amorim_Gaboardi_2022}.


\subsection{(Co)domain Completeness}\label{sec: domain completeness of TopKAT}

In general, TopKAT is not complete over relational models, which are crucial for
applications in program logics~\cite{Zhang_de_Amorim_Gaboardi_2022}.  However, it
was later showed that we can obtain a complete theory for relational
models by simply adding the axiom \(p ‚ä§ p ‚â• p\) to the theory of
TopKAT~\cite{Pous_Wagemaker_2023}. 

In this paper, we take a different approach than Pous et al.~\cite{Pous_Wagemaker_2023}:
instead of extending the TopKAT framework, we will restrict the completeness result.
In particular, the encoding of incorrectness logic and Hoare Logic in TopKAT~\cite{Zhang_de_Amorim_Gaboardi_2022}
relies only on the ability of TopKAT to compare the domain and codomain of two
relations.  This raises the question of whether TopKAT suffices for proving such
properties; that is, whether the following completeness results hold: for
\(e‚ÇÅ, e‚ÇÇ ‚àà \KAT_{K, B}\) (i.e. \(‚ä§\) does not appear in \(e‚ÇÅ\) and \(e‚ÇÇ\))
\begin{align*}
    \REL ‚äß \cod(e‚ÇÅ) ‚â• \cod(e‚ÇÇ) & ‚ü∫ \TopKAT ‚äß ‚ä§ e‚ÇÅ ‚â• ‚ä§ e‚ÇÇ & \text{codomain completeness} \\
    \REL ‚äß \dom(e‚ÇÅ) ‚â• \dom(e‚ÇÇ) & ‚ü∫ \TopKAT ‚äß e‚ÇÅ ‚ä§ ‚â• e‚ÇÇ ‚ä§ & \text{domain complete}
\end{align*}

In this section, we prove that these equivalences hold, even without the additional axiom.
However, they do \emph{not} hold if we allow expressions that contain top.
For example, let \(e‚ÇÅ ‚âú p ‚ä§ p\), and \(e‚ÇÇ ‚âú p\). Since \(p ‚ä§ p ‚â• p\) holds in
relational TopKAT, thus \(\dom(p ‚ä§ p) ‚â• \dom(p)\). 
However, \(p ‚ä§ p ‚ä§ ‚â• p ‚ä§\) is not provable in TopKAT, 
because the inequality is not valid with the language interpretation.
The incompleteness of codomain comparison can also be shown using the same example.

\subsection{Codomain completeness}

The core insight to prove the domain completeness result is 
to construct a specific relational interpretation \(h ‚àò i ‚àò G\),
where its codomain is equivalent to the complete TopKAT interpretation \(G ‚àò r\):
\[\cod(h ‚àò i ‚àò G(t)) = G ‚àò r(‚ä§ t),\]
where \(i\) is the natural inclusion homomorphism \(i: ùí¢_{K, B} ‚Ü™ ùí¢_{K_‚ä§, B}\), 
that maps every language to itself;
and \(h\) is the classical embedding of language KAT into relational KAT~\cite{Kozen_Smith_1997},
which we will recall as follows:
\[h(L) = \{(s, s ‚ãÑ s') ‚à£ s ‚àà GS, s' ‚àà L\}.\]
Although \(i\) will not change the outcome of \(G\),
it will add a new primitive action \(‚ä§\) to the alphabet, hence changing the outcome of \(h\).
Such addition will equate the codomain of \(h ‚àò i ‚àò G(t)\) 
with the complete TopKAT interpretation \(G ‚àò r\) of \(‚ä§ t\).
The proof of this equality is by simply computing both sides of the equation.

\begin{lemma}\label{the: codomain completeness core lemma}
    For any expression \(t ‚àà \KAT_{K, B}\),
    \[\cod(h ‚àò i ‚àò G(t)) = G ‚àò r(‚ä§ t).\]
\end{lemma}

\begin{proof}
    We explicitly write out the domain and codomain of the functions in
    the relational KAT interpretation \(h ‚àò i ‚àò G\) for the ease of the reader:
    \[\KAT_{K, B}
        \xrightarrow{G} ùí¢_{K, B}
        \xrightarrow{i} ùí¢_{K_‚ä§, B}
        \xrightarrow{h} ùí´(ùí¢_{K_‚ä§, B} √ó ùí¢_{K_‚ä§, B}).\]
    In this case, \(h\) is a KAT homomorphism from \(ùí¢_{K_‚ä§, B}\):
    \[h(S) = \{(s, s ‚ãÑ s‚ÇÅ) ‚à£ s ‚àà GS_{K_‚ä§, B}, s‚ÇÅ ‚àà S\}.\]
    Since the reduction \(r\) preserves expressions without \(‚ä§\),
    let \(t ‚àà \KAT_{K, B}\) (i.e. \(t\) does not contain \(‚ä§\)),
    \[G ‚àò r(‚ä§) = GS_{K_‚ä§, B} \\ G ‚àò r(t) = G(t).\]
    Therefore, for any expression \(t ‚àà \KAT_{K, B}\)
    \begin{align*}
        \cod(h ‚àò i ‚àò G(t))
         & = \{s Œ± s‚ÇÅ ‚à£ s Œ± ‚àà GS_{K_‚ä§, B}, Œ± s‚ÇÅ ‚àà G(t)\} \\
         & = GS_{K_‚ä§, B} ‚ãÑ G(t)                          \\
         & = (G ‚àò r(‚ä§)) ‚ãÑ (G ‚àò r(t))                     \\
         & = G ‚àò r(‚ä§ t). \qedhere
    \end{align*}
\end{proof}

\Cref{the: codomain completeness core lemma} established a connection between 
the codomain operator and the language interpretation of TopKAT.
Then by completeness of the language interpretation, 
we will obtain the completeness of codomain comparison.

\begin{theorem}[Codomain completeness]\label{the: codomain completeness}
    Given two expressions \(e‚ÇÅ, e‚ÇÇ ‚àà \KAT_{K, B}\) (i.e. expressions without \(‚ä§\)),
    then codomain comparison is complete:
    \begin{align*}
        \REL ‚äß \cod(e‚ÇÅ) ‚â• \cod(e‚ÇÇ) & ‚ü∫ \TopKAT ‚äß ‚ä§ e‚ÇÅ ‚â• ‚ä§ e‚ÇÇ.
    \end{align*}
\end{theorem}

\begin{proof}
    Given the natural inclusion homomorphism: \(i: \KAT_{K, B} ‚Üí \KAT_{K_‚ä§, B}\),
    we show that the following are equivalent:
    \begin{enumerate}
        \item \(\REL ‚äß \cod(e‚ÇÅ) ‚â• \cod(e‚ÇÇ).\)
        \item \(\cod(h ‚àò i ‚àò G(e‚ÇÅ)) ‚â• \cod(h ‚àò i ‚àò G(e‚ÇÇ)).\)
        \item \(\TopKAT ‚äß ‚ä§ e‚ÇÅ ‚â• ‚ä§ e‚ÇÇ.\)
    \end{enumerate}

    We first show that \(1 ‚üπ 2\), by definition, \(\REL ‚äß \cod(e‚ÇÅ) ‚â• \cod(e‚ÇÇ)\)
    implies \(\cod(I(e‚ÇÅ)) ‚â• \cod(I(e‚ÇÇ))\) for all relational KAT interpretations \(I\).
    Because \(h ‚àò i ‚àò G\) is a relational KAT interpretation, so \(1 ‚üπ 2\).

    We show \(2 ‚üπ 3\), which uses the equality discussed above, 
    and proved in~\Cref{the: codomain completeness core lemma}:
    \begin{align*}
             & \cod(h ‚àò i ‚àò G(e‚ÇÅ)) ‚â• \cod(h ‚àò i ‚àò G(e‚ÇÇ))           \\
        ‚ü∫ {} & G ‚àò r(‚ä§ e‚ÇÅ) ‚â• G ‚àò r(‚ä§ e‚ÇÇ)
             & \text{\Cref{the: codomain completeness core lemma}} \\
        ‚ü∫ {} & \TopKAT ‚äß ‚ä§ e‚ÇÅ ‚â• ‚ä§ e‚ÇÇ.
             & \text{Completeness of \(G ‚àò r\)}
    \end{align*}

    Finally, we show \(3 ‚üπ 1\), by \Cref{the: top element represent domain}:
    \[\TopKAT ‚äß ‚ä§ e‚ÇÅ ‚â• ‚ä§ e‚ÇÇ ‚üπ \TopREL ‚äß ‚ä§ e‚ÇÅ ‚â• ‚ä§ e‚ÇÇ ‚üπ \REL ‚äß \cod(e‚ÇÅ) ‚â• \cod(e‚ÇÇ). \qedhere\]
\end{proof}

\subsection{Domain completeness}

The domain completeness result can be derived from codomain completeness 
by observing properties of opposite TopKAT and the converse operator \((-)^{‚à®}\), 
both of which we will recall below.

For every TopKAT \(ùí¶\), we can construct the opposite TopKAT \(ùí¶^{\op}\) 
by reversing the multiplication operation, keeping the sorts and other operations unchanged:
\[p \mathbin{\hat{‚ãÖ}} q ‚âú q ‚ãÖ p,\]
where \(\hat{‚ãÖ}\) is multiplication in \(ùí¶^{\op}\) and \(‚ãÖ\) is multiplication in \(ùí¶\).
By definition, \((-)^{\op}\) is a involution, that is \({(ùí¶^{\op})}^{\op} = ùí¶\).
Furthermore, \((-)^{\op}\) is a TopKAT functor,
this means all TopKAT homomorphisms \(h: ùí¶ ‚Üí ùí¶'\) 
can be lifted to a TopKAT homomorphism on the opposite TopKAT \(h^{\op}: ùí¶^{\op} ‚Üí {ùí¶'}^{\op}\). 
The lifting \(h^{\op}\) is point-wise equal to \(h\):
\[‚àÄ p ‚àà ùí¶, h^{\op}(p) ‚âú h(p).\]
The fact that \(h^{\op}\) is a TopKAT homomorphism can be proven by unfolding the definition,
and the functor laws are satisfied because \(h^{\op}\) is point-wise equal to \(h\).

There are two important homomorphisms involving opposite TopKAT:
\begin{align*}
    (-)^{‚à®} & : (X √ó X)^{\op} ‚Üí (X √ó X) &
    \op & : \TopKAT_{K, B} ‚Üí \TopKAT^{\op}_{K, B} \\  
    (R)^{‚à®} & = \{(b, a) ‚à£ (a, b) ‚àà R\}, & 
    ‚àÄ p ‚àà K + B, \op & (p) = p.
\end{align*}
The \((-)^{‚à®}\) is the relational converse operator, 
the rules of homomorphism can simply be proven by unfolding of definitions.
The crucial property of \((-)^{‚à®}\) is that it flips the domain and codomain:
\begin{equation}\label{the: converse flips domain to codomain}
    \dom(R^{‚à®}) = \cod(R).
\end{equation}
Hence, allowing us to flip the result about codomains and apply it to domains.

\(\op\) is a homomorphism from free TopKAT to its opposite TopKAT;
it can be defined by lifting the embedding function \(K + B ‚Ü™ \TopKAT_{K, B}\) on primitives.
Intuitively, given a expression \(t ‚àà \TopKAT\), 
\(\op(t)\) will flip all the multiplications in \(t\) recursively.
\begin{lemma}\label{the: injectivity of op}
    the left inverse of \(op\) can be obtained by lifting itself through the \((-)^{\op}\) functor,
    \[\op^{\op}: \TopKAT^{\op} ‚Üí (\TopKAT^{\op})^{\op} = \TopKAT.\]
    Recall \(\op^{\op}\) is pointwise equal to \(\op\), 
    thus \(\op^{\op} ‚àò \op: \TopKAT ‚Üí \TopKAT\) is the identity interpretation 
    because it preserves all the primitives.
    Thus, \(\op\) has a left inverse, hence it is injective:
    \[e‚ÇÅ = e‚ÇÇ ‚ü∫ \op(e‚ÇÅ) = \op(e‚ÇÇ).\]
\end{lemma}

Finally, since the elements in \(\TopKAT^{\op}\) are the same as \(\TopKAT\), 
which are TopKAT expressions modulo provable TopKAT equalities,
theorems about TopKAT expressions are also true for elements in \(\TopKAT^{\op}\).
In particular, codomain completeness (\Cref{the: codomain completeness})
also holds in \(\TopKAT^{\op}\): 
for all expressions \(e‚ÇÅ, e‚ÇÇ ‚àà \TopKAT\),
\begin{equation}\label[equiv]{the: op codomain completeness}
    ‚ä§ ‚ãÖ \op(e‚ÇÅ) ‚â• ‚ä§ ‚ãÖ \op(e‚ÇÇ) ‚ü∫ \REL ‚äß \cod(\op(e‚ÇÅ)) = \cod(\op(e‚ÇÇ)).
\end{equation}

\begin{theorem}[Domain Completeness]\label{the: domain completeness}
    For all expressions \(e‚ÇÅ, e‚ÇÇ ‚àà \KAT\), the following equivalence hold:
    \[\REL ‚äß \dom(e‚ÇÅ) = \dom(e‚ÇÇ) ‚ü∫ \TopKAT ‚äß e‚ÇÅ ‚ä§ ‚â• e‚ÇÇ ‚ä§.\]
\end{theorem}

\begin{proof}
    \(‚ü∏\) direction is trivial by \Cref{the: top element represent domain};  
    and \(‚üπ\) direction can be derived as follows:
    let \(I\) be some relational interpretation,
    then \(I^{\op}(\op(-))^‚à®\) is also a relational interpretation:
    \[I^{\op}(\op(-))^‚à®: 
        \TopKAT \xrightarrow{\op} \TopKAT^{\op} \xrightarrow{I^{\op}} 
        (X √ó X)^{\op} \xrightarrow{(-)^{‚à®}} (X √ó X).\]
    Thus, we let \(I\) range over all relational interpretations:
    \begin{align*}
        & \REL ‚äß \dom(e‚ÇÅ) ‚äá \dom(e‚ÇÇ)  \\
        & ‚üπ ‚àÄ I, \dom(I(e‚ÇÅ)) ‚äá \dom(I(e‚ÇÇ)) \\
        & ‚üπ ‚àÄ I, \dom(I^{\op}(\op(e‚ÇÅ))^‚à®) ‚äá \dom(I^{\op}(\op(e‚ÇÇ))^‚à®) 
            &\text{specialize \(I\) as \(I^{\op}(\op(-))^‚à®\)}\\  
        & ‚üπ ‚àÄ I, \cod(I^{\op}(\op(e‚ÇÅ))) ‚äá \cod(I^{\op}(\op(e‚ÇÅ))) 
            &\text{\Cref{the: converse flips domain to codomain}}\\
        & ‚üπ ‚àÄ I, \cod(I(\op(e‚ÇÅ))) ‚äá \cod(I(\op(e‚ÇÅ))) 
            &\text{\(I^{\op}\) is pointwise equal to \(I\)}\\
        & ‚üπ ‚ä§ ‚ãÖ \op(e‚ÇÅ) ‚â• ‚ä§ ‚ãÖ \op(e‚ÇÇ) 
            &\text{\Cref{the: op codomain completeness}}\\
        & ‚üπ \op(‚ä§ ‚ãÖ e‚ÇÅ) ‚â• \op(‚ä§ ‚ãÖ e‚ÇÇ) 
            & \text{Definition of \(\op\)}\\
        & ‚üπ e‚ÇÅ ‚ä§ ‚â• e‚ÇÇ ‚ä§ & \text{\Cref{the: injectivity of op}}
    \end{align*}
\end{proof}

\begin{remark}
    Alternatively, \Cref{the: domain completeness} can also be proven 
    by constructing the following \(h'\):
    \begin{align*}
        h' & : ùí¢_{K, B} ‚Üí ùí´(ùí¢_{K, B} √ó ùí¢_{K, B})\\
        h' & (S‚ÇÅ) ‚âú \{(s‚ÇÅ Œ± s, Œ± s) ‚à£ s‚ÇÅ Œ± ‚àà S‚ÇÅ, Œ± s ‚àà GS_{K, B}\}.
    \end{align*}
    Then the proof would mirror that of \Cref{the: codomain completeness},
    replacing \(h\) with \(h'\) and replacing \(\cod\) with \(\dom\).
    However, the proof of \Cref{the: domain completeness} reveals more properties
    of maps like \((-)^{‚à®}\) and \(\op\), 
    thus we choose to present the current proof of \Cref{the: domain completeness} 
    instead of the alternative proof.
\end{remark}

\textbf{Extensions of Kleene algebra and reduction:}
soon after the completeness of Kleene algebra was proven~\cite{Kozen_1994},
it was realized that adding an embedded Boolean algebra can help reasoning
about control structures, such system is referred to as
Kleene algebra with tests (KAT)~\cite{Kozen_Smith_1997,Cohen_Kozen_Smith_1999}.
Later KAT was further extended to reason about failure~\cite{Mamouras_2017},
indicator variables~\cite{Grathwohl_Kozen_Mamouras_2014},
domain~\cite{Desharnais_M√∂ller_Struth_2006}, networks~\cite{Anderson_Foster_Guha_Jeannin_Kozen_Schlesinger_Walker_2014},
and relational reasoning~\cite{Antonopoulos_Koskinen_Le_Nagasamudram_Naumann_Ngo_2022}.
Kleene algebra has also been extended to reason about 
concurrency, as concurrent Kleene algebra~\cite{Hoare_van_Staden_M√∂ller_Struth_Zhu_2016, Kapp√©_Brunet_Silva_Zanasi_2018}
and concurrent Kleene algebra with observations~\cite{Kapp√©_Brunet_Silva_Wagemaker_Zanasi_2020}.
Many of these extensions can be seen as Kleene algebra with extra hypotheses~\cite{Cohen_1995,Doumane_Kuperberg_Pous_Pradic_2019}.
Although many hypotheses make the theory undecidable~\cite{Kozen_1996,Kozen_2002,Doumane_Kuperberg_Pous_Pradic_2019},
many useful hypotheses can be eliminated via reduction~\cite{Pous_Rot_Wagemaker_2021}.
Thus, our new perspective on reduction could potentially lead to streamlining of various previous proofs, 
and more general proofs of completeness results.

\textbf{Top element:}
Tarski's relational algebra~\cite{tarski_CalculusRelations_1941} contains the addition, 
mulitiplication, and identity operation of KA;  
in addition, relational algebra also include a top element. 
Hence attempts to incorporat Kleene star into relational algebra 
effectively create a super theory of TopKAT.
Unfortuantly, several attempts at these algebras turn out to be undecidable
because of the presence of intersection and 
converse operations~\cite{andrekaAxiomatizabilityPositiveAlgebras2011, pous_PositiveCalculusRelations_2018}.
With the intersection and converse operators removed, 
top element is proven to be individually useful in Kleene algebra:
for example, Mamouras~\cite{Mamouras_2017} uses the top element to forget program states,
and Antonopoulos et al.~\cite{Antonopoulos_Koskinen_Le_Nagasamudram_Naumann_Ngo_2022} 
uses top to design forward simulation rules for relational verification, 
and claim that relational incorrectness logic~\cite{murray_UnderApproximateRelationalLogic_2020a} 
can be encoded using BiKAT extended with top.
The completeness and decidability of TopKAT was first studied by Zhang et al.~\cite{Zhang_de_Amorim_Gaboardi_2022},
and concluded that TopKAT is not complete with relational models.
Later, Pous et al.~\cite{Pous_Wagemaker_2022,Pous_Wagemaker_2023} showed that 
both TopKA and TopKAT is complete with relational model with one additional axiom: \(p ‚ä§ p ‚â• p\),
and the theory remains PSPACE-complete, like KAT and TopKAT.
In this paper, we showed that TopKAT without the additional axiom is complete 
for a specific form of inequalities, namely when top only appears in the front or the end of the term.
Although this form of inequalities seem restrictive, 
they are enough to encode both Hoare and incorrectness logic~\cite{Zhang_de_Amorim_Gaboardi_2022}.

\textbf{Domain in KAT:}
The study of axiomatizing (co)domain in KAT has a long and rich history. 
Domain semiring~\cite{Desharnais_Struth_2011} 
and Kleene algebra with domain~\cite{Desharnais_M√∂ller_Struth_2006}
were two popular yet different axiomatizations of (co)domain in Kleene algebra with tests.
These two axiomitizations turn out to coincide in a large class of semirings~\cite{Fahrenberg_Johansen_Struth_Ziemi√°nski_2021}.
Various applications for domain in KAT have been discovered, including modeling
program correctness, predicate transformers, temporal logics, 
termination analysis, and many more~\cite{Desharnais_M√∂ller_Struth_2004}.
Many of these applications can even be efficiently automated~\cite{hofner_AutomatedReasoningKleene_2007}.
However, although the free relational model of these theories has been characterized~\cite{mclean_FreeKleeneAlgebras_2020},
the search for general complete interpretation remains unfruitful.
The complexity of these theories was recently shown to be EXPTIME-complete~\cite{Sedl√°r_2023},
a worse complexity class than PSPACE-complete for TopKAT.



\section{Conclusion And Open Problems}

In this paper, we exploit the homomorphic structure of reduction
to simplify the proof of various previous results~\cite{Zhang_de_Amorim_Gaboardi_2022}.
We have also showed that TopKAT is complete with respect to (co)domain comparison
in the relational models,
which lays a solid foundation for the use of TopKAT in (co)domain reasoning.

However, there are still several interesting unsolved problems about TopKAT.
Most of the incorrectness logic rules are written using hypotheses,
for example, the sequencing rule:
\[
    \frac{[a]~p~[b] \qquad [b]~q~[c]}{[a]~p ‚ãÖ q~[c]}
\]
corresponds to the implication \(‚ä§ a p ‚â§ ‚ä§ b ‚àß ‚ä§ b p ‚â§ ‚ä§ c ‚üπ ‚ä§ a p q ‚â§ ‚ä§ c\).
Although each individual inequality in the implication fits the desired form \(‚ä§ e‚ÇÅ ‚â• ‚ä§ e‚ÇÇ\).
it is unclear whether implications of the form
\[‚ä§ e‚ÇÅ‚ÇÅ ‚â§ ‚ä§ e‚ÇÅ‚ÇÇ ‚àß ‚ä§ e‚ÇÇ‚ÇÅ ‚â§ ‚ä§ e‚ÇÇ‚ÇÇ ‚àß ‚ãØ ‚àß ‚ä§ t‚Çô‚ÇÅ ‚â§ ‚ä§ t‚Çô‚ÇÇ ‚üπ ‚ä§ e‚ÇÅ ‚â§ ‚ä§ e‚ÇÇ\]
are complete with relational TopKAT or decidable.

Recently, there is an efficient fragment of KAT proposed, named 
\emph{Guarded Kleene algebra with tests}~\cite{Smolka_Foster_Hsu_Kapp√©_Kozen_Silva_2020}
or \emph{GKAT}.
This fragment not only enjoys nearly-linear time equality checking,
but also soundly models probabilistic computations as well. 
It would be interesting to see whether the completeness and decidability result of TopKAT
can be extended to GKAT, and whether the efficiency of GKAT will persist with the addition of top.

