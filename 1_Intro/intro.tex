\chapter{Introduction}
\label{chapter:introduction}
\thispagestyle{myheadings}

\section{An overview on Kleene Algebra}
\label{sec:history}

Kleene algebra, named after the eminent mathematician Stephen Cole Kleene, represents a pivotal development in mathematical logic, computer science, and formal languages. 
Originating in the mid-20th century, Kleene algebra emerged from Kleene's seminal work on regular sets and expressions~\cite{Kleene_1956}, where he introduced algebraic structures to formalize fundamental operations on regular languages. 
Kleene left a important open question about Kleene Algebra: whether there exists \emph{complete} algebraic system for regular language equality: an algebraic system that is capable of derive all the language equalities of regular expression.
There are numerous systems proposed and are closely related~\cite{Kozen_1990}, yet the modern Kleene Algebra and its completeness proof is often attributed to Kozen~\cite{Kozen_2001,Kozen_1994}.

Given the close relation to regular languages, it is no surprise that the study of Kleene Algebra often makes heavy use of automata theory.
The automata perspective underpins the other important property of Kleene Algebra, that is, decidability.
Specifically, the behavioral equivalence of two automata (or more generally) coalgebra can be obtained by bisimulation on the automata~\cite{rutten_UniversalCoalgebraTheory_2000}.
And bisimulation usually is decidable for finite automata.
This is later characterized by the bialgebraic approach~\cite{jacobs_BialgebraicReviewDeterministic_2006}, although we will not dive deep into coalgebra, many of the techniques used in this paper are inspired by this framework.

The decidability and completeness of Kleene Algebra has inspired a suite of applications in programming languages and verifications; specifically, in the areas of network system~\cite{Anderson_Foster_Guha_Jeannin_Kozen_Schlesinger_Walker_2014,Foster_Kozen_Milano_Silva_Thompson_2015, Smolka_Kumar_Kahn_Foster_Hsu_Kozen_Silva_2019},
concurrent programs~\cite{hoare_ConcurrentKleeneAlgebra_2009,Kapp√©_Brunet_Silva_Wagemaker_Zanasi_2020,Kapp√©_Brunet_Silva_Zanasi_2018}, 
probabilistic systems~\cite{mciver_UsingProbabilisticKleene_2006, McIver_Rabehaja_Struth_2011}, 
relational verification~\cite{Antonopoulos_Koskinen_Le_Nagasamudram_Naumann_Ngo_2022},
and program schematology~\cite{Angus_Kozen_2001}.
Notice that despite the decidability of KA and KAT, the decision procedure is PSPACE-complete~\cite{Cohen_Kozen_Smith_1999}, which should be infeasible for large systems.
However, in real-world testing, network systems based on KAT was able to out-perform state of the art network verifier~\cite{Smolka_Kumar_Kahn_Foster_Hsu_Kozen_Silva_2019}.
This phenomenon is explained by an efficient fragment of KAT named \emph{Guarded Kleene Algebra with Tests} (GKAT)~\cite{Smolka_Foster_Hsu_Kapp√©_Kozen_Silva_2020}. Concretely, the particular fragment of GKAT enjoys a more efficient automaton structure that enables fast equivalence checking.

\paragraph{Our Contributions}

\begin{itemize}
    \item Proved that KAT cannot encode incorrectness logic. Demonstrated the insufficiency of domain reasoning in KAT.
    \item Developed the system TopKAT, and proven it is sound and complete with respect to its trace/language interpretation and general relational model.
    \item Developed a new notion of reduction, which is based on homomorphism from the free algebra.
    \item Proved TopKAT is complete with respect to domain comparisons.
    \item Designed the syntax and semantic of CF-GKAT, enabling control-flow verification of \command{while}-programs.
    \item Designed the decision procedure of CF-GKAT based on GKAT automaton.
    \item Proving the decision procedure is sound and complete, and also enjoys nearly-linear time complexity, assuming the number of primitive tests are fixed.
\end{itemize}

\section{Technical Background}

\subsection{Extensions of Kleene algebra And Their Models}

A \emph{Kleene algebra} is an idempotent semiring with a star operation, written
$p^*$, that satisfies the following \emph{unfolding}, \emph{left induction},
and \emph{right induction} rules:
\[
    p^* = 1 + p p^* = 1 + p^* p, \\
    p r + q  \leq  r  \implies  p^* q  \leq  r, \\
    r p + q  \leq  r  \implies  q p^*  \leq  r;
\]
the ordering here is the conventional ordering in idempotent semirings: \(p  \leq  q  \triangleq  p + q = q.\)
It is known that the right-hand version of unfolding and induction rule 
can be removed while preserving the same equational theory~\cite{Kozen_Silva_2020}.
Yet, we will focus on the standard definition of KA in this paper.
\begin{lemma}\label{the: well known fact about KA}
    Following are well-known facts in Kleene algebra
    \begin{itemize}
        \item All the Kleene algebra operations preserve order.
        \item The following equations are true for the star operation:
              \[ p^*  \cdot  p^* = p^* \\ (p^*)^* = p^*.\]
    \end{itemize}
\end{lemma}

A Kleene algebra with tests (KAT) is a Kleene algebra with an embedded Boolean algebra,
where the conjunction, disjunction, and identities in the Boolean algebra coincide with 
the addition, multiplication, and the identities of Kleene algebra.  
We refer to elements of this embedded Boolean algebra as \emph{tests}.

Given an algebraic theory, we can construct its \emph{free model} 
over a finite set \( \Sigma \), 
called the \emph{alphabet}~\cite{burrisCourseUniversalAlgebra1981}.  
The free model consists of all the terms formed by \( \Sigma \) modulo 
provable equivalences of the algebra. The operations of the free model are obtained 
by lifting the term-level operations to equivalence classes.

The above construction can be extended to the case of KAT and TopKAT, 
suppose that we are given two disjoint finite sets $K$ (the
\emph{action alphabet}) and $B$ (the \emph{test alphabet}).  Elements of $K$ and
$B$ are called \emph{primitive actions and primitive tests}, respectively. 
KAT terms over the alphabet \(K, B\) are defined with the following grammar:
\[e  ‚âú  b  ‚àà  B  ‚à£  p  ‚àà  K  ‚à£  1  ‚à£  0  ‚à£  e_1 + e_2  ‚à£  e_1  ‚ãÖ  e_2  ‚à£  e^*  ‚à£  \overline{e_b},\]
where \(e_b\) does not contain primitive actions.
The \emph{free KAT} over \(K, B\), written $\KAT_{K,B}$, 
consists of terms over \(K, B\) modulo provable KAT equivalences.  
The tests of the free KAT are Boolean terms, i.e. terms formed by
primitive tests and Boolean operations modulo Boolean axioms.  A similar
construction applies to TopKAT, where an additional symbol \( ‚ä§ \) was added 
as the largest element in the theory; we denote the free TopKAT over $K,B$ as
\(\TopKAT_{K, B}\).  We sometimes omit the alphabets \(K\) and \(B\) when they
are irrelevant or can be inferred.

In the paper, we frequently consider terms modulo provable equalities, i.e. in the
context of its corresponding free model.  For example, given \(e_1, e_2  \in  \KAT\),
we will say \(e_1 = e_2\) when they are provably equal using the theory of KAT.
Although the free model seems trivial, it leads to simpler and more modular
proofs of some properties of algebraic theories, as we will see in~\Cref{chapter:TopKAT}.

Other important models that we will use in this paper are language (Top)KATs and
relational (Top)KATs, which we review here.  An \emph{atom} (short for ``atomic
test'') over a test alphabet \(B = \{b_{1}, b_{2},  \ldots , b_{n}\}\) is a sequence of the form
\[\hat{b_{1}}  \cdot  \hat{b_{2}}  \cdot   \cdots   \cdot \hat{b_{n}} \text{ where } \hat{b_{i}}  \in  \{b_{i}, \bar{b_{i}}\}.\] 
We denote atoms as \( \alpha ,  \beta ,  \gamma ,  \ldots \) and the set of all atoms as \(\At\).

A \emph{guarded string} (or \emph{guarded word}) over \(K, B\) is an alternation 
between atoms and primitive actions that starts and ends in atoms: 
\[ \alpha _{0}p_{1} \alpha _{1}  \cdots  p_{n}  \alpha _{n} \text{ where } p_{i}  \in  K,  \alpha _{i}  \in  \At;\] 
where each action is ``guarded'' by an atom.
A guarded string is similar to a program trace. These traces record the initial, intermediate and final machine states observed during execution, as well as the actions that occurred between those states. % chktex 36
Because the value of the indicator variable matters only for control flow, we do not consider indicators to be part of the machine state; hence, machine states in a guarded word are drawn from $\At$.

\begin{example} 
    Let $B = \{ b‚ÇÅ, b‚ÇÇ \}$ and $K = \{ p‚ÇÅ, p‚ÇÇ \}$.
    Now the guarded word \[b‚ÇÅ \overline{b‚ÇÇ} ‚ãÖ p‚ÇÅ ‚ãÖ \overline{b‚ÇÅ} b‚ÇÇ ‚ãÖ p‚ÇÇ ‚ãÖ \overline{b‚ÇÅ} \overline{b‚ÇÇ}\] represents a program trace that starts out in a machine state where $b‚ÇÅ$ is true (but $b‚ÇÇ$ is not).
    The program then executes the action $p‚ÇÅ$, after which $b‚ÇÇ$ is true (but $b‚ÇÅ$ is not).
    Finally, the program goes on to execute the action $p‚ÇÇ$, and halts in a state where neither $b‚ÇÅ$ nor $b‚ÇÇ$ is true.
\end{example}

We denote the set of all guarded
strings over alphabet \(K, B\) as \(GS_{K, B}\), and we will omit the alphabet
\(K, B\) when it is irrelevant or can be inferred from context.  The notation
\( \alpha  s\) denotes a guarded string starting with atom \( \alpha \) with the rest of the string
\(s\); similarly, \(s  \alpha \) denotes a guarded string that ends with atom \( \alpha \) with
rest of the string being \(s\).

\begin{definition}[Language/trace KAT~\cite{Kozen_Smith_1997}]
  The \emph{language KAT} (also called ``\emph{trace KAT}'') over an alphabet \(K, B\) is
  denoted as \(\mathcal{G}_{K, B}\), or simply \(\mathcal{G}\) if no confusion can arise.

  The elements are sets of guarded strings (called \emph{guarded languages}), 
  and the tests are sets of atoms.
  The additive identity 0 is the empty set, and the multiplicative identity 1 is
  the set of all the atoms \(\At\).  The addition operator is set union, and the
  multiplication operator is defined as follows:
    \[W_{1}  ‚ãÑ  W_{2}  ‚âú  \{w_{1}  Œ±  w_{2}  ‚à£  w_{1}  Œ±   ‚àà  W_{1},  Œ±  w_{2}  ‚àà  W_{2}\}.\]
    The star operation is defined non-deterministically 
    iterating the multiplication operator:
    \[W^*  ‚âú   ‚ãÉ_{i  ‚àà ‚Ñï} W^i \text{ where } W^0 = \At, W^{k+1} = W  ‚ãÑ  W^k.\]
\end{definition}


Another useful type of KAT are relational ones, where each element is a relation
\(R  \subseteq  X  \times  X\) over a fixed set \(X\).  In applications, the set $X$ typically
represents the set of all possible program states, and each relation $R$
represents a program by relating each possible input to the corresponding
output.

\begin{definition}[Relational KAT]
  A relational KAT is a KAT $\mathcal{R}$ consists of relations over a fixed set \(X\) 
  (though $\mathcal{R}$ need not contain every relation over $X$),
  and it is closed under the following operations. 
  The tests are all the relations that are subsets of the identity relation.  
  The additive identity 0 is the empty set, and
  the multiplicative identity is the identity relation:
  \[1  \triangleq  \{(x, x)  \mid  x  \in  X\}.\] The addition operator is set union, and the
  multiplication operation is relational composition:
  \[R_{1} ; R_{2} = \{(x, z)  \mid   \exists  y  \in  X, (x, y)  \in  R_{1}, (y, z)  \in  R_{2}\}.\] 
  Finally, the star operation is defined as:
  \[R^*  \triangleq   \bigcup _{i  \in  \mathbb{N}} R^i \text{ where } R^0 = 1, R^{k+1} = R ; R^k.\] We denote the
  class of all relational KATs as \(\REL\).
\end{definition}

\emph{TopKAT} extends the theory of KAT with the largest element \( \top \), i.e.
\( \top   \geq  p\) for all elements \(p\).  The \emph{language TopKAT} over an alphabet
\(K, B\) has the same carrier and operations as \(\mathcal{G}_{K_ \top , B}\), where \(K_ \top \) is
the set \(K\) joined with a new primitive action \( \top \); and the largest element
is the full language \(GS_{K_ \top , B}\).

The \emph{relational TopKAT} is a relational KAT that contains the complete relation:
\[ \top   \triangleq  \{(x, y)  \mid  x, y  \in  X\};\] we denote the set of all relational TopKATs as
\(\TopREL\).  It is known that there are equations that are valid in relational
TopKAT, but are not derivable by the axioms of
TopKAT~\cite{Zhang_de_Amorim_Gaboardi_2022}; however, by adding the axiom
\(p  \top  p  \geq  p\), the theory becomes complete over relational
TopKATs~\cite{Pous_Wagemaker_2022,Pous_Wagemaker_2023}.  
In this paper, instead of working with a more complex theory, 
we will show that TopKAT without any additional axiom already suffices 
for the purpose of encoding domain comparisons. 
Indeed, TopKAT is complete with respect to domain comparison inequalities,
which can be used to encode both incorrectness logic and Hoare logic.

In this paper, 
we will use \(\dom\) and \(\cod\) to denote the 
conventional (co)domain operators on relations, namely, for any relation \(R\):
\begin{align*}
    \dom(R)  \triangleq  \{x  \mid   \exists  y, (x, y)  \in  R\} \\
    \cod(R)  \triangleq  \{y  \mid   \exists  x, (x, y  \in  R)\}.
\end{align*}
To demonstrate how TopKAT models (co)domain comparisons,
we take any relational TopKAT \(\mathcal{R}\) and two relations \(R_{1}, R_{2}  \in  \mathcal{R}\),
and we denote the complete relation as \( \top \):
\begin{lemma}[TopKAT encodes (co)domain comparison]\label{the: TopKAT encodes domain PRIMITIVE}
    \begin{align*}
        R_{1}  \top   \supseteq  R_{2}  \top   \iff  \dom(R_{1})  \supseteq  \dom(R_{2}) \\
         \top  R_{1}  \supseteq   \top  R_{2}  \iff  \cod(R_{1})  \supseteq  \cod(R_{2})
    \end{align*}
\end{lemma}
If we regard \(R_{1}\) and \(R_{2}\) as the input output relation of two programs,
which is typically encoded by KAT terms,
we can see that \(R_{1}  \top   \supseteq  R_{2}  \top \) reflects that  
the domain of \(R_{1}\) is larger than the domain of \(R_{2}\);
and similarly for the inequality \( \top  R_{1}  \supseteq   \top  R_{2}\).
Thus, given two KAT terms \(e_1, e_2  \in  \KAT_{K, B}\), we call inequalities like
\(e_1  \top   \geq  e_2  \top \) \emph{domain comparison inequalities},
and \( \top  e_1  \geq   \top  e_2\) \emph{codomain comparison inequalities}.
Notice that the term \( \top  e_1\) is a shorthand for \( \top   \cdot  i(e_1)\),
where \(i\) is the inclusion function \(\KAT_{K, B}  \hookrightarrow  \TopKAT_{K, B}\).
In the rest of the paper, we will sometimes leave this inclusion function implicit.
These two forms of inequalities will be the focus of 
our completeness results in~\Cref{sec: domain completeness of TopKAT}.

We also know another class of TopKATs named \emph{general relational TopKATs},
which is denoted as \(\TopGREL\).
The top element of general relational TopKAT is not necessarily the complete relation,
but the largest relation in the model.
All equations in the general relational TopKAT can be derived using the theory of TopKAT.

However, the completeness of \(\TopGREL\) came at the cost of expressive power:
every predicate that is expressible using general relational TopKAT 
is already expressible using relational KAT~\cite{Zhang_de_Amorim_Gaboardi_2022},
so the extension with top, in the case of general relational TopKAT, 
does not grant any extra expressive power.
In~\Cref{the: TopGREL expressive power}, 
we show that this result is a simple corollary of our new reduction result.

We are also interested in maps between models:
A \emph{KAT homomorphism} \(f\) is a map between two KATs \(\mathcal{K}\) and \(\mathcal{K}'\)
s.t. it preserves the sorts and operations:
given a test \(b\) in \(\mathcal{K}\) then \(f(b)\) is a test in \(\mathcal{K}'\);
and all the KAT operations (complement, identities, addition, multiplication, and star) are preserved:
\begin{align*}
    f & : \mathcal{K}  \to  \mathcal{K}'\\
    f(\bar{b}) & = \overline{f(b)} \\  
    f(1) & = 1 \\  
    f(0) & = 0 \\
    f(p + q) & = f(p) + f(q) \\  
    f(p  \cdot  q) & = f(p)  \cdot  f(q) \\  
    f(p^*) & = f(p)^*.
\end{align*}
Similarly, a \emph{TopKAT homomorphism} is a KAT homomorphism that preserves the
largest element.

\subsection{Interpretation, Completeness, and Injectivity}\label{sec: completeness background}

Consider a KAT equation such as \(p  \cdot  b  \cdot  \bar{b} = 0\). To determine its
validity in a particular KAT \(\mathcal{K}\), we need to assign meaning to it by
interpreting each primitive as an element in \(\mathcal{K}\); that is, by defining a map
\(\hat{I}\) of type \(K + B  \to  \mathcal{K}\).  Such a map \(\hat{I}: K + B  \to  \mathcal{K}\) induces a
unique KAT homomorphism \(I : \KAT_{K,B}  \to  \mathcal{K}\) inductively defined on the term 
as follows:
\begin{equation}
    \begin{aligned}
        I(p)       &  \triangleq  \hat{I}(p)    & \text{ where } p  \in  K + B \\
        I(\overline{e_b}) &  \triangleq  \overline{I(e_b)} 
            & \text{\(e_b\) does not contain primitive actions} \\
        I(e_1 + e_2) &  \triangleq  I(e_1) + I(e_2)                     \\
        I(e_1  \cdot  e_2) &  \triangleq  I(e_1)  \cdot  I(e_2)                     \\
        I(e^*)     &  \triangleq  I(t)^*
    \end{aligned}
\end{equation}
In fact, every KAT homomorphism from a free model arises this way: there is a
bijection between functions of type \(K + B  \to  \mathcal{K}\) and KAT homomorphisms of type
\(\KAT_{K, B}  \to  \mathcal{K}\), for any KAT \(\mathcal{K}\).  
Because the homomorphism \(I\) and the function \(\hat{I}\) are equivalent, 
we will refer to them interchangeably as \emph{KAT interpretations} 
and denote both of them as \(I\).

The above result enables us to define a homomorphism from the free KAT just by
defining its action on the primitives; saving us time to check the equations
that a homomorphism must satisfy.  It also allows us to prove that two
interpretations are equal by arguing that they map the primitives to
equal values.

Given a KAT \(\mathcal{K}\), and two terms \(e_1, e_2  \in  \KAT_{K, B}\) we say that \(\mathcal{K}  \models  e_1 = e_2\) if
\[ \forall  I : \KAT_{K, B}  \to  \mathcal{K}, I(e_1) = I(e_2).\] In particular, 
for two terms in the free model \(e_1, e_2  \in  \KAT_{K, B}\),
\(\KAT_{K, B}  \models  e_1 = e_2\) is equivalent to \(e_1 = e_2\).  
For a collection of models \(\mathsf{K}\), 
we say that \(\mathsf{K}  \models  e_1 = e_2\) if for all \(\mathcal{K}  \in  \mathsf{K}\),
\(\mathcal{K}  \models  e_1 = e_2\).  For example, \(\REL  \models  e_1 = e_2\) means that \(e_1 = e_2\) is
valid in all relational KATs.  All the above notations and terminologies can be
similarly extended to TopKAT.

Theories like KAT and TopKAT are designed to model practical
programs, so it is important to know if they can model all the desirable
equations between programs. If the theory of KAT can derive all the equalities
for a particular interpretation \(I\), namely:
\[\KAT_{K, B}  \models  e_1 = e_2  \iff  I(e_1) = I(e_2),\]
we say that the theory of KAT is \emph{complete} with respect to \(I\).
Recall that \(\KAT_{K, B}  \models  e_1 = e_2\) is equivalent to \(e_1 = e_2\);  
thus, by definition, an interpretation \(I\) is complete if and only if it is injective.
One of such interpretation is the guarded string interpretation
\(G: \KAT_{K, B}  \to  \mathcal{G}_{K, B}\)~\cite{Kozen_Smith_1997},
defined by lifting the following action on the primitives:
\[
    G(b) = \{ \alpha   \mid  \text{\(b\) appears positively in \( \alpha \)}\}, \\
    G(p) = \{ \alpha  p  \beta   \mid   \alpha ,  \beta   \in  \At\}.
\]
Because the trace interpretation is the complete interpretation of KAT, we often name it trace semantics as write it as \(G(e)\) instead of \(G(e)\), when it is convenient.

% AAA: What is this a corollary of?
% CZ: I changed it to a lemma. I originally named it corollary, because it can be easily observed.

% AAA: The previous discussion is a bit confusing. We begin by talking about a
% specific complete interpretation G, but right after that we say "when it
% holds", giving the impression that G may or may not be complete.  It would be
% useful to split the previous discussion into some material about general
% interpretations (that we would like to be complete), and interpretations that
% are similar to G, and that we know are complete.

In several previous works, the term ``free model'' refers to the range (set of
reachable elements) of a complete interpretation.  Since a complete
interpretation is an injective homomorphism, 
such interpretation induces an isomorphism on its range, 
thus our definition of free model is equivalent to these definitions.

Many previous proofs can also be explained by seeing complete interpretations as
injective homomorphisms: the proof for completeness of relational KATs
constructs an injective homomorphism $h$ from a language KAT into a relational
KAT~\cite{Kozen_Smith_1997}.  Since both \(G\) and \(h\) are injective
homomorphisms, \(h  \circ  G\) is also an injective homomorphism, hence a complete
interpretation.  Since \(h  \circ  G\) is a relational interpretation:
\[\KAT_{K, B}  \models  e_1 = e_2  \implies  \REL  \models  e_1 = e_2  \implies  h  \circ  G(e_1) = h  \circ  G(e_2);\]
then the completeness of \(h  \circ  G\) implies
\((h  \circ  G)(e_1) = (h  \circ  G)(e_2)  \iff  \KAT_{K, B}  \models  e_1 = e_2\). Hence,
\[\KAT_{K, B}  \models  e_1 = e_2  \iff  \REL  \models  e_1 = e_2,\]
i.e. the theory of KAT is complete with respect to relational KAT.

% Function/homomorphism composition will be used frequently in this paper,
% but sometimes simply writing \(f  \circ  g\) will be confusing without knowing
% the domain and codomain of function \(f\) and \(g\).
% Therefore, we will use the notation \(X \xrightarrow{g} Y \xrightarrow{f} Z\)
% to denote the composition of \(f: Y  \to  Z\) and \(g: X  \to  Y\) when it is desirable.

% AAA: I think the above notation is standard enough; we don't have to explain
% what it means.
% CZ: Removed

Besides using composition of injective homomorphisms, another technique commonly
used to prove injectivity is to construct a left inverse: 
if a (Top)KAT homomorphism \(f: \mathcal{K}  \to  \mathcal{K}'\) has a left inverse homomorphism \(g: \mathcal{K}'  \to  \mathcal{K}\) 
i.e. \(g  ‚àò  f = id_{\mathcal{K}}\), then \(f\) is injective.  
Notice that \(g\) does not need to be a homomorphism for \(f\) to be injective,
however, in the case where \(f\) is an interpretation, 
\(g\) being a homomorphism makes the equality \(g  ‚àò  f = id_{ùí¶}\) easier to check.
Because both \(g  ‚àò  f\) and \(id_{ùí¶}\) are all interpretations,
they are equal if and only if they have the same action on all the primitives.
% AAA: This is only true because

Finally, we provide a shorthand for domain reasoning. 
For two terms \(e_1, e_2  ‚àà  \KAT\), we write
\[\REL  ‚äß  \dom(e_1)  ‚â•  \dom(e_2),\] when 
\(\dom(I(e_1))  ‚äá  \dom(I(e_1))\) for all relational KAT interpretations \(I\);  
and similarly for relational TopKAT and general relational TopKAT.  
Then \Cref{the: TopKAT encodes domain PRIMITIVE} implies the following:
\begin{lemma}\label{the: top element represent domain}
    For two KAT terms \(e_1, e_2  \in  \KAT_{K, B}\):
    \begin{align*}
        \TopREL  ‚äß  e_1  ‚ä§   ‚â•  e_2  ‚ä§  &  ‚ü∫ \REL  ‚äß  \dom(e_1)  ‚â•  \dom(e_2) \\
        \TopREL  ‚äß   ‚ä§  e_1  ‚â•   ‚ä§  e_2 &  ‚ü∫  \REL  ‚äß  \cod(e_1)  ‚â•  \cod(e_2)
    \end{align*}
\end{lemma}

\section{Guarded Kleene Algebra With Tests}

Guarded Kleene Algebra with Tests (GKAT)~\cite{Smolka_Foster_Hsu_Kapp√©_Kozen_Silva_2020} is a efficient fragment of Kleene Algebra with tests. Specifically, GKAT uses tests to ``guard'' the non-deterministic operations like \(+\) and \(*\), to make it more akin to simply \command{while}-programs. 
A GKAT expression over an alphabet \(K, B\) is defined as follow:
\begin{align*}
    \BExp ‚àã e_b, f_b & ‚âú 
        b ‚àà B ‚à£ 1 ‚à£ 0 ‚à£ e_{b} ‚àß f_{b} ‚à£ e_{b} ‚à® f_{b} ‚à£ \overline{e_{b}} ; \\
    \GKAT ‚àã e, f & ‚âú 
        p ‚àà K ‚à£ e_b ‚à£ e ‚ãÖ f ‚à£  \comITE{e_b}{e}{f} ‚à£ \comWhile{e_b}{e} .
\end{align*}
Sometimes, like in~\cref{tab: thompson's construction}, we will use the compact notation \(e +_{e_b} f\) for \(\comITE{e_b}{e}{f}\) and \(e^{(e_b)}\) for \(\comWhile{e_b}{e}\).
In fact, these new \command{if}-statement and \command{while}-loop can be embedded back into KAT in the usual manner~\cite{Kozen_1997}:
\begin{align*}
    \comITE{e_b}{e}{f} & ‚âú e_b ‚ãÖ e + \overline{e_b} ‚ãÖ f \\  
    \comWhile{e_b}{e} & ‚âú (e_b ‚ãÖ e)* ‚ãÖ \overline{e_b}
\end{align*}
This embedding into KAT gives Guarded Kleene Algebra with Tests a natural trace semantics: by computing the trace of the underlying KAT term; and a PSPACE decision procedure for trace-equivalence. Because the trace semantics of GKAT is obtained by the embedding into KAT we will overload the notation \(G(e)\) as the trace interpretation of a GKAT expression \(e\). 

The main advantage of GKAT, compare to KAT, is its efficient decision procedure. Such decision procedure is enabled by its deterministic nature, namely all the non-deterministic operations are guarded by tests. Thus, endowing GKAT a different automaton structure.

\begin{definition}[GKAT automaton]\label{def:GKAT-automaton}
    A GKAT automaton \(A ‚âú ‚ü®S, Œ¥, sÃÇ‚ü©\) over an alphabet \(K, B\) consists of a state set \(S\), a transition function \(Œ¥: S ‚Üí 2 + K √ó S\), and a start state \(sÃÇ ‚àà S\).
\end{definition}
where \(2\) denotes \(\{\accept, \reject\}\), which represents accept and reject respectively.
Intuitively, the transition function of a GKAT automaton tells us, given a state $q$ and an atom $Œ±$ accounting for the truth value of each primitive test, to either \emph{reject} the input, represented by $Œ¥(q, Œ±) = \reject$, \emph{accept} the input, represented by $Œ¥(q, Œ±) = \accept$, or to \emph{transition} to a new state in $S$ after executing an action from $K$, represented by $Œ¥(q, Œ±) ‚àà K √ó S$.

People familiar with coalgebra~\cite{jacobs_IntroductionCoalgebraMathematics_2016,rutten_UniversalCoalgebraTheory_2000} might realize that this definition is a pointed coalgebra over the following \emph{signature} (or \emph{dynamics}):
\[2 + K √ó (-).\]

A GKAT automaton induces a guarded language in a fairly straightforward manner.
\begin{definition}
 Given a GKAT automaton $A ‚âú ‚ü® S, Œ¥, \hat{s} ‚ü©$, we define $G( - )_A: S ‚Üí ùí¢$ as the (pointwise) smallest function satisfying the following rules for all $s ‚àà S$ and $Œ± ‚àà \At$:
 \begin{mathpar}
  \inferrule{%
   Œ¥(s, Œ±) = \accept
  }{%
   Œ± ‚àà G( s )_A
  }
  \and
  \inferrule{%
   Œ¥(s, Œ±) = (p, s') \\
   w ‚àà G( s' )_A
  }{%
   Œ±pw ‚àà G( s )_A
  }
 \end{mathpar}
 Finally, we define the guarded language semantics of $A$ by setting $G( A ) = G( \hat{s} )_A$.
\end{definition}

\citet{Smolka_Foster_Hsu_Kapp√©_Kozen_Silva_2020} was able to design a efficient trace equivalence decision procedure based on the classical Hopcroft-Karp algorithm~\cite{hopcroft_LinearAlgorithmTesting_1971}

\begin{theorem}[Decidability for GKAT~\cite{Schmid_Kapp√©_Kozen_Silva_2021}]
    Given two finite GKAT automata $A‚ÇÄ$ and $A‚ÇÅ$, it is decidable whether they represent the same guarded language, i.e., whether $G( A‚ÇÄ ) = G( A‚ÇÅ )$.
    The algorithm to do this has a complexity that is nearly-linear\footnote{$ùí™(\hat{Œ±}(n))$, where $\hat{Œ±}$ is the inverse Ackermann function; c.f.~\cite{Tarjan75}.} in the total number of states.
\end{theorem}

When given two expression \(e\) and \(f\), the decision procedure will first convert it into two trace equivalent automaton via the \emph{Thompson's Construction}~\cite{Smolka_Foster_Hsu_Kapp√©_Kozen_Silva_2020}. Concretely, two GKAT automata \(A_e\) and \(A_f\) s.t.
\[G(A_e) = G(e); \qquad G(A_f) = G(f).\]
Then, apply the efficient decision procedure to decide the trace-equivalence of \(A_e\) and \(A_f\)



