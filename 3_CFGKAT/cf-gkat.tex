
% continuations
\newcommand{\conti}[1]{\mathbf{#1}}
\newcommand{\acc}[1]{{\conti{acc} ~ #1}}  % accept with an output indicator value
\newcommand{\ret}{{\conti{ret}}}  % return, terminate the program
\newcommand{\brk}[1]{\conti{brk} ~ #1}  % break with an output indicator value
\newcommand{\jmp}[1]{{\conti{jmp} ~ #1}} % goto a label

% paper specific
\newcommand{\contWith}{\mathbf{cont}}
\newcommand{\exitWith}{\mathbf{exit}}
\newcommand{\iter}{\mathrm{iter}}


\chapter{Decompilation Verification With GKAT}
\label{chapter:Conclusions}
\thispagestyle{myheadings}

% set this to the location of the figures for this chapter. it may
% also want to be ../Figures/2_Body/ or something. make sure that
% it has a trailing directory separator (i.e., '/')!
\graphicspath{{4_Conclusion/Figures/}}

\section{Overview}


\section{Introduction}

There are many different notions of program equivalence, each with its own properties in terms of granularity and computational complexity.
At one end of the spectrum, syntactical equality compares two program solely based on its syntax tree. Although decidable, this technique will not equate ``intuitively equivalent'' programs like the following:
\begin{mathpar}
 \comITE{t}{p}{q}
 \and
 \comITE{¬ t}{q}{p}
\end{mathpar}
Conversely, input-output equivalence relates all programs that will yield the same output when given the same input.
While this kind of equivalence closely captures the intuition of program equivalence, it is also well-known to be undecidable.

Situated between these two extremes, \emph{Guarded Kleene Algebra with Tests}~\cite{kozen_BohmJacopiniTheorem_2008a,Schmid_Kappé_Kozen_Silva_2021},
or \emph{GKAT} for short, reasons about \emph{trace equivalence} between simple \command{while}-programs:
it abstracts the meaning of the primitive tests and actions that occur in a program, and instead focus on how tests determine which actions are performed, and in what order.
%FIXME: CZ: I think we can make the previous sentence better...
For example, the two programs above are equivalent in GKAT:\@ they both execute $p$ when $t$ holds, and $q$ when it does not.
GKAT is also able to verify nontrivial equivalences like
\[
 \{\ \comWhile{t}{p}\ \};\ \comWhile{s}{\{\ q;\ \comWhile{t}{p}\ \}} ≡
 \comWhile{t ∨ s}{\{\ \comITE{t}{p}{q}\ \}}
\]
Despite its robust equational theory, GKAT equivalence is decidable in nearly-linear time (assuming the set of test variables is fixed)~\cite{Schmid_Kappé_Kozen_Silva_2021}, making GKAT a reasonable compromise between complexity and granularity.

Nevertheless, GKAT still lacks important constructs that are ubiquitous among control flow manipulation algorithms.
First, as mentioned, GKAT disregards the meaning of primitive programs and tests.
For instance, when given a program like
\begin{equation}
 \comITE{y \neq 0}{\{\ x := 42;\ p\ \}}{\{\ x := 42;\ q\ \}}%
 \label[prog]{prog: assignment inside branches}
\end{equation}
we can note that a change in the value of $x$ does not have effect on whether or not $y \neq 0$.
Hence, it should be possible to factor the assignment to $x$ out of the branches, and obtain
\begin{equation}
 x := 42;\ \comITE{y \neq 0}{p}{q}%
 \label[prog]{prog: assignment outside branches}
\end{equation}
Unfortunately, GKAT does not admit this equivalence, precisely because it is agnostic with respect to the meaning of primitive actions.
However, moving to a setting that accounts for the semantics of actions is hard, because Turing completeness — and by extension, undecidability — lurks nearby.
In fact, just considering commutativities of non-interfering statements, like 
\[(x := x + 1); (y := y + 1) = (y := y + 1); (x := x + 1), \]
the theory can be quickly become undecidable~\cite{Kozen_1996, kuznetsov_ComplexityReasoningKleene_2023, azevedodeamorim_KleeneAlgebraCommutativity_2024}.

Second, GKAT excludes non-local control-flow structures like \(\command{goto}\), \(\comBrk\), and \(\comRet\).
In a general imperative language, lacking these commands will not limit its expressivity -- indeed, these control structures can be recovered using variables~\cite{erosa-hendren-1994}.

However, lacking both variables and non-local control structures, GKAT is not able to express all control flows of real-world programs.
As a very concrete example, consider the programs below.
\Cref{prog: goto version two state automaton} has a control flow strategy based purely on labels and $\texttt{goto}$.
Meanwhile, \Cref{prog: break version two state automaton} is structured as a loop with the option to terminate early using $\comBrk$.
These programs happen to be trace equivalent (i.e., they always execute the same actions in the same order) but represent behavior not expressible in plain GKAT~\cite{kozen_BohmJacopiniTheorem_2008a,schmid_GuardedKleeneAlgebra_2021}.
\begin{align}
  & \begin{aligned}
      & \comLabel{ℓ₀};\ \comIT{\neg t}{\comGoto{ℓ₁}};\ p;\ \comIT{t}{\comGoto{ℓ₁}};\ q;\ \comGoto{ℓ₀};\ \comLabel{ℓ₁}
    \end{aligned}\label[prog]{prog: goto version two state automaton}
 \\[3pt]
  & \comWhile{t}{\{\ p;\ \comITE{¬ t}{q}{\comBrk}\ \}}
 \label[prog]{prog: break version two state automaton}
\end{align}

As it turns out, deciding equivalence between these complex programs is essential in verifying control-flow manipulation procedures.
Specifically, consider the control flow structuring phase of a decompiler~\cite{cifuentes-1994}, which is tasked with converting conditional and unconditional jumps into more conventional control flow constructs as best as possible.
\Cref{prog: goto version two state automaton} can be thought of as pseudo-assembly that models the input of this process, and \Cref{prog: break version two state automaton} is a plausible outcome.
Thus the control-flow structuring process is correct when \Cref{prog: goto version two state automaton,prog: break version two state automaton} are equivalent.

To overcome these limitations of GKAT, we propose control flow GKAT (CF-GKAT), a extension of GKAT that is capable of equating some interesting real-world programs.
Concretely, we extend GKAT by two sets of structures, each solving a limitation discussed before.

First, we add \emph{indicator variables}, which can be assigned and tested against hardcoded values, and do not appear in other primitive actions and tests.
Thus, assignments like $x := 42$ are allowed, but assignments like $x := y + 1$ are not.
This addition strikes a delicate balance: it is weak enough to still exclude general computation (keeping program equivalence decidable), yet strong enough to model the equivalence of \Cref{prog: assignment inside branches,prog: assignment outside branches}.
Furthermore, indicator variables are widely used in real-world control-flow manipulation algorithms~\cite{yakdan_NoMoreGotos_2015,erosa-hendren-1994}, and this addition empowers CF-GKAT to verify them. 

Second, we extend GKAT with non-local control-flow constructs, including \(\comGoto{\!}\), \(\comBrk\) and \(\comRet\).
However, the non-local nature of these commands prevents a compositional semantics --- after all, the precise meaning of a statement like \(\comBrk\) depends on its context.
To overcome these challenges, we propose a intermediate semantics, named \emph{continuation semantics}, which appends a continuation to every trace (\Cref{sec:continuation-semantics}). 
Specifically, at the end of the trace, the program can either accept (terminate normally), break, return, or go to a label.
Then, the trace semantics of the program can be obtained by resolving these continuations.

%FIXME: CZ: This paragraph is still bit out of place to me
Inspired by the triangular correspondence between deterministic trace semantics, GKAT, and GKAT automaton, we were able to design an automaton model for CF-GKAT, where every CF-GKAT expression can be unfolded into an CF-GKAT automaton through thompson's construction (\Cref{tab: thompson's construction}), while preserving the continuation semantic (\Cref{the:thompson-correctness}). 
Furthermore, CF-GKAT automata and continuation semantics can be lowered into GKAT automata and trace semantics respectively, while preserving their semantical correspondence (\Cref{the:cf-gkat-automaton-lowering-correctness}). 
With the Thompson's construction and the lowering, we are able to reduce the problem of deciding trace equivalence of programs into deciding the bisimulation of two GKAT automata, which is known to be efficient. 

\smallskip
As a result of these extensions, CF-GKAT is able to soundly and completely verify trace equivalence of a larger class of programs, while preserving the nearly-linear efficiency of GKAT.
For instance, it can automatically check that \Cref{prog: break version two state automaton,prog: goto version two state automaton} are equivalent to each other, and also to \Cref{prog: indicator version two state automaton} (below), which is their single-loop equivalent obtained via the Böhm-Jacopini theorem~\cite{DBLP:journals/cacm/BohmJ66}.
\begin{align}
 \begin{aligned}
   & x := 1;\ \comWhile{x \neq 0}{\{ \\
   & \qquad \comITE{x = 1 ∧ t}{\{\ p;\ x := 2\ \} \\
   & \qquad\qquad}{\comITE{x = 2 ∧ ¬ t} {\{\ q;\ x := 1\ \} \\
   & \qquad\qquad}{x := 0} }\ \}}                                 \\
 \end{aligned} \label[prog]{prog: indicator version two state automaton}
\end{align}

To put this theory to work, we implemented an equivalence checker for CF-GKAT\@.
This checker is able to validate highly non-trivial program transformations, such as the aforementioned Böhm-Jacopini conversion.
We also implemented a front end to the equivalence checker that can convert C code to CF-GKAT expressions by leveraging Clang's parser.
The resulting tool is able to automatically validate the outcome of Erosa and Hendren's classic \command{goto} elimination procedure~\cite{erosa-hendren-1994}, as well as the the control flow structuring pass of several decompilers.



\section{CF-GKAT Expression and Semantics}
%FIXME: CZ: multiple indicator variable?

In this section, we introduce the language of CF-GKAT, and gradually develop its semantics.
We begin by explaining the syntax of CF-GKAT;\@ after that, we delve into the semantics of its tests.
We then introduce the intermediate semantic model of \emph{(labeled and indexed families of) guarded languages with continuations}, which is flattened into to a model based on \emph{guarded languages}.
Having defined these tools, we then conclude by giving a semantics to CF-GKAT programs in this model.
Along the way, we will single out and explain some of the finer points using examples.

% We fix a single indicator variable $x$, as well as a finite set $I$ of possible indicator values.

\subsection{Syntax}

The syntax of CF-GKAT consists of two levels, similar to GKAT\@.
At the bottom level, there are \emph{tests}; these are Boolean assertions that can occur as guards inside conditional statements, or within assertions that occur in the program text.
To model them, we fix a finite set of primitive tests $T$, which represent uninterpreted expressions that may or may not hold.
The full syntax is as follows.
\[
 \BExp ∋ b, c ::=
 \false
 \mid \true
 \mid t ∈ T
 \mid {\color{blue}x = i\ (i ∈ I)}
 \mid b ∨ c
 \mid b ∧ c
 \mid ¬ b
\]
Compared to GKAT, tests in CF-GKAT include the \emph{indicator variable test} $x = i$ (highlighted in \textcolor{blue}{blue}) for each \emph{indicator value} $i$ drawn from a finite but fixed set of possible indicator values $I$.
As the notation suggests, this test holds when the indicator variable $x$ currently has the value $i$.
% Since the set \(I\) is finite, any complex predicate \(P\) on \(I\) can be encoded as a disjunction that enumerates all the values in \(P\)\ : \[⋁ \{(x = i) ∣ P(i)\}.\]

The top level syntax of GKAT is built using a finite set of uninterpreted commands \(Σ\) (the \emph{primitive actions}), as well as \emph{assertions} of the form $\comAssert{b}$, where $b \in \BExp$ is a test.
Expressions are composed using sequencing, \texttt{if} statements, and \texttt{while} loops.
CF-GKAT extends the base elements of the syntax with indicator variable assignments \(x := i\) (for each $i \in I$), which changes the value of the indicator variable \(x\) to \(i\).
In addition, it adds the non-local control flow commands $\comBrk$ and $\comRet$, as well as $\comGoto{\ell}$ and $\comLabel{\ell}$, where $\ell$ is taken from a fixed but finite set of labels $L$.
The full syntax is given below; constructs new compared to GKAT are highlighted in \textcolor{blue}{blue} again.
\begin{align*}
 \CFGKAT ∋ e, f ::= {}&
 \comAssert{b}
 ∣ p ∈ Σ
 ∣ {\color{blue}x := i\ (i ∈ I)}
 ∣ e; f
 ∣ \comITE{b}{e}{f} ∣ {} \\
 &
 \comWhile{b}{e}
 ∣ {\color{blue} \comBrk}
 ∣ {\color{blue} \comRet}
 ∣ {\color{blue} \comGoto{ℓ}\ (ℓ ∈ L)}
 ∣ {\color{blue} \comLabel{ℓ}\ (ℓ ∈ L)}
\end{align*}

\begin{remark}
We do not specify the sets $T$, $\Sigma$, $I$ and $L$ of (respectively) primitive tests, primitive actions, indicator values, and labels in more detail on purpose.
When comparing CF-GKAT expressions, it is more practical to gather the symbols that appear in the corresponding positions, and construct the relevant set from them.
For example, when we compare \Cref{prog: assignment inside branches} to \Cref{prog: assignment outside branches}, we infer that $T = \emptyset$, $\Sigma = \{ p, q \}$, $I = \{ 0, 42 \}$, and $L = \emptyset$; similarly, when comparing \Cref{prog: goto version two state automaton} to \Cref{prog: break version two state automaton}, we set $T = \{ t \}$, $\Sigma = \{ p, q \}$, $I = \emptyset$ and $L = \{ \ell_0, \ell_1 \}$.
This is sound, because including more symbols in these sets does change whether or not the two programs are actually equivalent.
\end{remark}

A \emph{valid program}, or \emph{program} for short, is an expression without (1)~duplicate labels, (2)~$\command{goto}$ commands with an undefined label, or (3)~$\comBrk$ statements that occur outside a loop.
For the sake of simplicity, we assume that the reader does not require a more formal definition of this notion.

\begin{example}
 Any GKAT expression is a valid program.
 Also, \cref{prog: break version two state automaton,%
  prog: goto version two state automaton,%
  prog: indicator version two state automaton}
 from the introduction are all valid CF-GKAT expressions.
 The following expressions are \emph{not} valid programs:
 \begin{align*}
  \comLabel{ℓ}; (\comITE{t}{\comLabel{ℓ}; p}{q}) \tag{the label \(ℓ\) is defined twice} \\
  (\comWhile{\true}{p}); \comGoto{ℓ} \tag{the label \(ℓ\) is undefined} \\
  \comITE{t}{\comBrk}{p} \tag{$\comBrk$ appears outside a loop}
 \end{align*}
\end{example}

%FIXME: move to semantics
\begin{remark}
 For soundness, it is important that the indicator variable $x$ does not
 occur in any primitive test $t ∈ T$ or action $p ∈ Σ$.
 In other words, $x$ is completely divorced from the other actions in the program,
 and may influence execution only by affecting flow control.
\end{remark}

\subsection{Boolean semantics}

To assign a semantics to CF-GKAT expressions, we first need to talk about the semantics of the Boolean sublanguage.
Intuitively, each Boolean expression in CF-GKAT symbolically denotes a set of execution contexts in which it is true.
But how do we model an execution context?
Because the primitive tests from $T$ are uninterpreted, we represent them by simply listing the ones that are true; the unlisted tests are then assumed to be false.
This coincides with the semantics of (G)KAT~\cite{Schmid_Kappé_Kozen_Silva_2021,Kozen_1997}. % 36
As for the indicator tests, we include the current value of the indicator variable $x$ in the execution context.
This means that each execution context is of the form $(α, i)$, for $α ⊆ T$ and $i ∈ I$.

Putting these ideas together, we can calculate the set of execution contexts that satisfy a given Boolean expression \(b ∈ \BExp\) by induction.
This set will be regarded as the semantics of \(b\).

\begin{definition}
 Let $\At$ denote $2^T$, the set of \emph{atoms} of (the free Boolean algebra generated by) $T$.
 We define the \emph{Boolean semantics} function $⟦-⟧: \BExp → 2^{\At × I}$ inductively,
 as follows.
 \begin{align*}
  ⟦ \false ⟧ & ≜ ∅
    & ⟦ t ⟧& ≜ \{ (α, i) ∣ t ∈ α, i ∈ I \}
    & ⟦ b ∨ c ⟧ & ≜ ⟦ b ⟧ ∪ ⟦ c ⟧ \\
  ⟦ \true ⟧  & ≜ \At × I
    & ⟦ x = i ⟧ & ≜ \{ (α, i) ∣ α ∈ \At \}
    & ⟦ b ∧ c ⟧ & ≜ ⟦ b ⟧ ∩ ⟦ c ⟧ \\
  & & & & ⟦ ¬ b ⟧ & ≜ \At × I \setminus ⟦ b ⟧
 \end{align*}
\end{definition}

\begin{example}
 Take $T = \{ t_1, t_2 \}$ and $I = \{ 1, 2, 3 \}$; then we can calculate that
 \[
  ⟦ (t_1 ∨ ¬ t_2) ∧ (x = 2) ⟧ = \{
  (\{ t_1, t_2\}, 2),
  (\{ t_1 \}, 2),
  (∅, 2)
  \}
 \]
 In other words, the test above holds in execution contexts where $t_1$ and $t_2$ are both true (first element) or both false (last element), and those where $t₁$ is true but $t₂$ is false (middle element).
 In contrast, $⟦ x = 1 ∧ x = 3⟧ = ∅$, which is to say that this test does not hold in any execution context, because the indicator variable \(x\) cannot be both 1 and 3 at the same time.
\end{example}

\subsection{Guarded languages with continuations}\label{sec:continuation-semantics}

We can now turn our attention to the semantics of CF-GKAT\@.
Like (G)KAT, the semantics of CF-GKAT is given in terms of \emph{guarded languages}~\cite{Schmid_Kappé_Kozen_Silva_2021,Kozen_1997}, which are best thought of as sets of symbolic traces of the program.
These traces record the initial, intermediate and final machine states observed during execution, as well as the actions that occurred between those states. % chktex 36
Because the value of the indicator variable matters only for control flow, we do not consider indicators to be part of the machine state; hence, machine states in a guarded word are drawn from $\At$.
\begin{definition}
 A \emph{guarded word} is a sequence of the form $α₁ p₁ α₂ p₂ ⋯ α_{n-1} pₙ αₙ$, where \(αᵢ ∈ \At\) and \(pᵢ ∈ Σ\); that is to say, guarded words are elements of the regular language $\At ⋅ (Σ ⋅ \At)^*$.
 We refer to sets of guarded words as \emph{guarded languages}; the set of guarded languages is denoted $𝒢$.
\end{definition}
\begin{example}
 Let $T = \{ t₁, t₂ \}$ and $\Sigma = \{ p₁, p₂ \}$.
 Now the guarded word $\{ t₁ \}p₁\{ t_2 \}p₂\emptyset$ represents a program trace that starts out in a machine state where $t_1$ is true (but $t₂$ is not).
 The program then executes the action $p₁$, after which $t_2$ is true (but $t₁$ is not).
 Finally, the program goes on to execute the action $p₂$, and halts in a state where neither $t₁$ nor $t₂$ is true.
\end{example}

Our semantics of a CF-GKAT expression will ultimately be a guarded language.
To get there, however, we will need continuation semantics, a semantics that can account for the indicator variables as well as the non-local flow control statements.
The remainder of this subsection is dedicated to explaining the domain of this continuation semantics, based on \emph{guarded words with continuations}.
Intuitively, these are guarded words equipped with a piece of information called a \emph{continuation}, which contains relevant information about how flow control continues after the program ends.
This could, for instance, tell us that the execution will continue at a location marked by a label.

The possibility of including continuation information at the end of a trace allows us to define a semantics of CF-GKAT expressions inductively.
This is especially necessary in the case of non-local control flow, because the label may occur in an entirely different part of the program whose traces have not yet been computed.
Once the continuation semantics of a CF-GKAT program is known, we can flatten it into a guarded language.

\begin{definition}
 A \emph{guarded word with continuation} is a pair $w ⋅ c$,
 where $w$ is a guarded word and $c$ is a \emph{continuation},
 which can take on one of the following forms for $i ∈ I$ and $ℓ ∈ L$:
 \begin{mathpar}
  \acc{i} \and
  \brk{i} \and
  \ret \and
  \jmp{(ℓ, i)}
 \end{mathpar}
 We write $C$ for the set of all continuations.
 A set of guarded words with continuations is a \emph{guarded language with continuations}; the set of guarded languages with continuations is written $𝒞$.
\end{definition}
Intuitively, the different types of continuation may be interpreted as follows:
\begin{itemize}
    \item
    The continuation $\acc{i}$ represents that the trace has successfully reached the end of this part of the program, with indicator value \(i\).
    Execution can be picked up if the program is put in a larger context --- e.g., if $w \cdot \acc{i}$ is a trace of $e$, then it may be combined with a trace found when $f$ is executed with indicator value $i$ to compute the semantics of $e; f$.
    \item
    A continuation of the form $\brk{i}$ signals that the trace ends by halting the loop in which it occurs.
    Execution can resume only after this loop (with indicator value $i$).
    This kind of trace cannot be composed on the right, as is done for traces with accepting continuations, because we first need to enclose it in a loop to halt; it will then be converted into $\acc{i}$.
    \item
    The continuation $\ret$ represents a trace that ends in the program halting completely.
    Traces of this kind will percolate upwards in the semantics, without changing their continuation.
    These are intended to model the $\comRet$ statement, which halts the program no matter how deeply it is nested.
    In this case, the indicator value does not matter any more.
    \item
    Finally, the continuation $\jmp{(\ell, i)}$ is put on traces that will continue executing from label $\ell$, with indicator value $i$.
    Like $\brk{i}$ and $\ret$, these traces do not compose on the right, but unlike $\brk{i}$ this continuation does not change, as jump resolution happens only at the end, when the semantics is known for the entire program.
\end{itemize}

\begin{example}
 Let $w$ be the guarded word from the previous example;
 the guarded word with continuation $w ⋅ \jmp{(ℓ₁, 2)}$
 represents a partial program trace that takes the steps represented by $w$,
 and will continue executing at the label $ℓ₁$ with an indicator value of $2$.
\end{example}

%FIXME: change L to G to avoid conflict with sets of labels

\subsection{Indexed families and sequencing}
The continuation semantics of a CF-GKAT expression takes a starting indicator value, and produces a guarded language with continuations representing the traces of that program when started with this indicator value.
This semantics is modeled by the following.
\begin{definition}
An \emph{indexed family} of guarded languages (with continuations), or ``indexed family'' for the sake of brevity, is function from $I$ to guarded languages (with continuations).
Typically, we use \(G\) and \(H\) to denote an indexed family.
To lighten notation, we write \(Gᵢ\) to denote \(G(i)\).
\end{definition}

Similar to guarded languages, indexed families can be composed in several ways.
In particular, we are interested in the sequencing operation and the Kleene star operation of indexed families, because these will turn out to be useful when defining the continuation semantics of CF-GKAT\@.

When sequencing two families \(G\) and \(H\), the traces in \(G_i\) with a continuation of the form $\acc{j}$ will be composed with traces in \(H_j\); traces with different continuations are copied over in full, because they do not compose on the right.
Formally, this operation is defined as follows.

\begin{definition}%
\label{def:sequencing}
 Let $G, H: I \to 𝒞$.
 We write $G ⋄ H$ for the \emph{sequencing} (or \emph{concatenation}) operation of \(G\) and \(H\), which is defined as the smallest family of guarded languages with continuations (in the pointwise order) satisfying the following rules for all $i,j ∈ I$ as well as all $ℓ ∈ L$:
 \begin{mathpar}
  \inferrule{%
   wα ⋅ \acc{j} ∈ Gᵢ \\
   αx ⋅ c ∈ Hⱼ
  }{%
   wαx ⋅ c ∈ (G ⋄ H)ᵢ
  }
  \and
  \inferrule{%
   w ⋅ c ∈ Gⱼ \\
   c \in \{ \brk{i}, \acc{i}, \jmp{(\ell, i)} \}
  }{%
   w ⋅ c ∈ (G ⋄ H)ⱼ
  }
 \end{mathpar}
\end{definition}
The first rule composes accepting traces in $G$ with traces in $H$, picking up with the indicator value where the first trace left off.
Note also that this rule requires the last atom in the trace on the left to match the first atom in the trace on the right, because we want the second trace to start from the machine state computed in the first trace.
This mirrors the \emph{fusion product} used to define the sequential composition of guarded languages (without continuations)~\cite{Kozen_1997}.
The last rule ensures that traces that encountered non-local control flow within $G$ are preserved in $G ⋄ H$.

\begin{example}%
\label{example:sequencing}
 Let $I = \{1,2\}$, and let $G$ and $H$ be indexed families given by:
 \begin{align*}
  G₁ & = \{ αpβ ⋅ \brk{1},\; βpα ⋅ \acc{2} \}
    & G₂& = \{ αqβ \cdot \acc{1} \} \\
  H₁ & = \{ γqβ ⋅ \ret \}
    & H₂ & = \{ αrβ ⋅ \jmp{(1, ℓ₁)} \}
  \intertext{
   Then we can compute that the sequencing $G ⋄ H$ is the following indexed family:
  }
  (G ⋄ H)₁ & = \{ αpβ ⋅ \brk{1},\; βpαrβ ⋅ \jmp{(1, ℓ₁)} \}
           & (G ⋄ H)₂ & = ∅
 \end{align*}
 Here, we find that $(G \diamond H)_1$ contains $\alpha p \beta \cdot \brk{1}$ by the second rule, because $G_1$ does.
 Furthermore, the trace $\beta p \alpha \cdot \acc{2}$ in $G_1$ is composed with $\alpha r \beta \cdot \jmp{(1, \ell_1)}$ from $H_2$ to form $\beta p \alpha r \beta \cdot \jmp {(1, \ell_1)}$ in $(G \diamond H)_1$, by the first rule.
 The set $(G \diamond H)_2$ is empty, because despite the fact that $αqβ \cdot \acc{1} \cdot \acc{1} \in G_2$, there is no trace in $H_2$ that starts with $\beta$, and so neither rule can apply.
\end{example}

\subsection{continuation semantics}
With the theory of indexed families in place, we can now define the continuation semantics $⟦e⟧^♯$ of a CF-GKAT program $e$ in terms of an indexed family.
We start with the base cases.

\begin{definition}[continuation semantics, base]
 For all $i, j ∈ I$, we define the following sets:
 \begin{align*}
  ⟦\comAssert{b}⟧ᵢ^♯ & ≜ \{ α ⋅ \acc{i} ∣ (α, i) ∈ ⟦ b ⟧ \}
    & ⟦ \comGoto{ℓ} ⟧ᵢ^♯ & ≜ \{ α ⋅ \jmp{(ℓ, i)} ∣ α ∈ \At \} \\
  ⟦p⟧ᵢ^♯             & ≜ \{α p β ⋅ \mathbf{acc}\ i ∣ α, β ∈ \At\}
    & ⟦ \comLabel{ℓ} ⟧ᵢ^♯ & ≜ \{ α ⋅ \acc{i} ∣ α ∈ \At \} \\
  ⟦ x := j ⟧ᵢ^♯ & ≜ \{ α ⋅ \acc{j} ∣ α ∈ \At \}
    & ⟦ \comBrk ⟧ᵢ^♯ & ≜ \{ α ⋅ \brk{i} ∣ α ∈ \At \} \\
  ⟦ \comRet ⟧ᵢ^♯ & ≜ \{ α ⋅ \ret ∣ α ∈ \At \}
 \end{align*}
 \end{definition}

Each of these base syntax elements yields a simple (finite) indexed family.
For the constructs $\command{return}$, $\command{goto}$, and $\command{break}$, all traces terminate immediately in the corresponding continuation.

We inherit the semantics of assertions and primitive actions from (G)KAT~\cite{Kozen_1997,Schmid_Kappé_Kozen_Silva_2021}. % chktex 36
Assertions have traces that accept when their only atom satisfies the test.
A primitive action $p$ yields traces of the form $\alpha p \beta \cdot \acc{i}$ for all $\alpha, \beta \in \At$ to witness that $p$ is uninterpreted: we could reach any other machine state by running $p$.
The only information retained is the value of the indicator variable, because primitive actions cannot interact with indicators.
In contrast with primitive actions, an assignment like $x := j$ has traces that accept immediately, without changing the machine state; however, each trace ends with the indicator value $j$ --- regardless of the initial indicator value $i$.

Finally, labels are encoded as no-operations, which makes them neutral for sequencing operator, i.e., we have $⟦ \comLabel{ℓ} ⟧^♯ ⋄ G = G = ⟦ \comLabel{ℓ} ⟧^♯ ⋄ G$ for all indexed families $G$.
This is because labels serve only as potential starting points of execution; we will leverage them in the next subsection.

We now turn our attention to the program composition operators.
These are generalizations of the guarded language semantics of GKAT~\cite{Schmid_Kappé_Kozen_Silva_2021}.
First of all, the $\comITE{b}{e}{f}$ filters out traces in the semantics of the $e$ that satisfy the guard $b$, as well as the traces in $f$ that invalidate it.

 \begin{definition}[continuation semantics, branching]
 Let $e, f \in \CFGKAT$.
 We define $⟦ \comITE{b}{e}{f} ⟧^♯$ as the least indexed family that satisfies the following rules for all $i \in I$:
 \begin{mathpar}
    \inferrule{
        \alpha \in ⟦ b ⟧ \\
        \alpha{}w \cdot c \in ⟦ e ⟧^♯ᵢ
    }{%
        \alpha{}w \cdot c \in ⟦ \comITE{b}{e}{f} ⟧^♯ᵢ
    }
    \and
    \inferrule{
        \alpha \not\in ⟦ b ⟧ \\
        \alpha{}w \cdot c \in ⟦ f ⟧^♯ᵢ
    }{%
        \alpha{}w \cdot c \in ⟦ \comITE{b}{e}{f} ⟧^♯ᵢ
    }
 \end{mathpar}
 \end{definition}

 The semantics of the sequencing operator is easy: it just composes the semantics of the operands with the sequencing operator we have for indexed families.
 For loops, some more care is needed because traces can be iterated, and we need to account for early termination.

 \begin{definition}[continuation semantics, sequencing and loops]%
 \label{def:intermediate-sequencing-loops}
 Let $e, f \in \CFGKAT$.
 We define
 \(
    ⟦e; f⟧^♯ ≜ ⟦ e ⟧^♯ ⋄ ⟦ f ⟧^♯
 \).
 Also, for all $b \in \BExp$, we define $⟦\comWhile{b}{e}⟧^♯$ as the least indexed family satisfying:
 \begin{mathpar}
    \inferrule{%
        i \in I \\
        \alpha \not\in ⟦ b ⟧
    }{%
        \alpha \cdot \acc{i} \in ⟦\comWhile{b}{e}⟧^♯ᵢ
    }
    \and
    \inferrule{%
        \alpha \in ⟦ b ⟧ \\
        \alpha w \cdot c \in (⟦ e ⟧^♯ ⋄ ⟦\comWhile{b}{e}⟧^♯)ᵢ
    }{%
        \alpha w \cdot \lfloor c \rfloor \in ⟦\comWhile{b}{e}⟧^♯_i
    }
 \end{mathpar}
 The operation $\lfloor - \rfloor$ in the last rule is defined by $\lfloor c \rfloor = \acc{i}$ when $c = \brk{i}$, and $\lfloor c \rfloor = c$ otherwise.
\end{definition}

%FIXME: We need some kind of example around here, preferably based on a program from the introduction.

The first rule accounts for traces that halt immediately because the loop guard is false.
The second rule allows prepending traces from the loop body that satisfy the guard.
Because of the way sequencing works, body traces that end in $\brk{i}$ may occur; the second rule converts their continuations to $\acc{i}$, signaling that the loop has been exited and normal control flow can resume.

\smallskip
The semantics we have so far defines the traces of a program starting from the beginning.
However, a CF-GKAT program can be started from any label.
To obtain these traces for a given label $\ell$, we must descend into the program until we encounter the corresponding label statement.
For the base cases, this is relatively simple to accomplish: just check if we start at the label.

\begin{definition}[continuation semantics starting from a label, base]
 Let $e ∈ \CFGKAT$.
 For each $ℓ ∈ L$, we define the following guarded languages with continuations:
 \begin{align*}
  ⟦\comAssert{b}⟧ᵢ^ℓ & ≜ ∅
    & ⟦ \comGoto{ℓ'} ⟧ᵢ^ℓ  & ≜ ∅ \\
  ⟦p⟧ᵢ^ℓ             & ≜ ∅
    & ⟦ \comLabel{ℓ'} ⟧ᵢ^ℓ & ≜ \{ α ⋅ \mathbf{acc}\ i ∣ α ∈ \At,\ ℓ = ℓ' \} \\
  ⟦x := j⟧ᵢ^ℓ        & ≜ ∅
    & ⟦ \comBrk ⟧ᵢ^ℓ     & ≜ ∅ \\
  ⟦ \comRet ⟧ᵢ^ℓ     & ≜ ∅
 \end{align*}
\end{definition}
Note how none of these cases has a trace, except the one for $⟦ \comLabel{ℓ'} ⟧ᵢ^ℓ$ when $\ell' = \ell$, which accepts immediately.
With these cases covered, we can then treat the inductive step.

\begin{definition}[continuation semantics starting from a label, sequencing and branching]
Let $e, f \in \CFGKAT$, $b \in \BExp$ and $\ell \in L$.
We define the following indexed families to cover the traces of CF-GKAT programs starting from the label $\ell$ when composed using branching or sequencing:
\begin{mathpar}
    ⟦\comITE{b}{e}{f}⟧^ℓᵢ ≜ ⟦ e ⟧^ℓᵢ \cup ⟦ f ⟧^ℓᵢ
    \and
    ⟦e; f⟧^ℓᵢ ≜ (⟦ e ⟧^ℓ ⋄ ⟦ f ⟧^♯)ᵢ \cup ⟦ f ⟧^ℓᵢ
\end{mathpar}
\end{definition}
For branching, the semantics starting from $\ell$ disregards the guard and descends into the operands.
The sequencing case is more interesting: here, we still need to account for the traces that start from the beginning of $f$ after executing a trace in $e$ starting from the label $ℓ$.

The only remaining case to cover is the loop.
In this case, if we start execution from a label somewhere in the body, we may need to start the loop again after completing the loop body.
On the other hand, early termination in the loop body still needs to be turned into an accepting trace.

\begin{definition}[continuation semantics starting from a label, loops]
Let $e \in \CFGKAT$ and $b \in \BExp$.
We define the indexed family $⟦\comWhile{b}{e}⟧^ℓ$ below, where $\lfloor - \rfloor$ is as in \Cref{def:intermediate-sequencing-loops}:
\[
    ⟦\comWhile{b}{e}⟧^ℓ_i = \{ w \cdot \lfloor c \rfloor \mid w \cdot c \in (⟦ e ⟧^ℓ ⋄ ⟦\comWhile{b}{e}⟧^♯)ᵢ \}
\]
\end{definition}

\subsection{Guarded language semantics}

The continuation semantics of a CF-GKAT program $e$ in terms of indexed families $⟦ e ⟧^♯$ uses continuations to record how a trace ends.
In particular, some traces may end with the continuation of the form $\jmp{(i, \ell)}$, signaling that computation needs to continue from the label $\ell$.
But we have just seen that we can also obtain the traces of $e$ starting from $\ell$, in the form of the indexed family $⟦ e ⟧^ℓ$.
This means that we have the information we need to resolve the jumping continuations, if we just put together the right traces.
We will end this section by doing just that.

To formalize our approach, we need a way to refer to the intermediate CF-GKAT semantics of a program as a whole, i.e., for all indicator values, starting from either the beginning or some label.

% FIXME: I don't think using super script here is not a good idea,
% as it doesn't align with the notation later used for λ.
% I think we should just call this jump map, name it λ and use the bracket notation.
% TK: Does the above still apply? I don't see how superscripts clash with a different notation..?

\begin{definition}
 A \emph{labeled family of guarded languages (with continuations)}, or \emph{labeled family} for short, is a function $G$ from $L + ♯$ to indexed families of guarded languages (with continuations), e.g., $G: L + ♯ → I → 𝒞$.
 We often use superscripts to denote the value at a given label $♯$, writing $L^ℓ$ for $L(ℓ)$.
 Note that under this convention, $L^ℓ$ is an indexed family, which means that we may further unravel by writing $L^ℓ_i$ to obtain the guarded language with continuations $L(ℓ, i)$.
\end{definition}

Crucially, we can retrofit the continuation semantics $⟦ e ⟧$ as a labeled family; after all, $⟦ e ⟧^\sharp$ is an indexed family, and so is $⟦ e ⟧^\ell$ for each $\ell \in L$.
We will thus treat $⟦ e ⟧$ as such from this point on.

\smallskip
To resolve the jumps in a labeled family of guarded languages with continuations, we resolve the traces ending in $\jmp{(ℓ, i)}$ by looking up the traces that originate from label $ℓ$ with indicator value $i$.
We also remove the continuations $\acc{i}$ and $\ret$, because those come with traces that either reached the end of the program, or encountered a $\comRet$ statement respectively.
Continuations of the form $\brk{i}$ should not occur at the top level when computing the semantics of a program, so we can ignore them.
The result is a labeled family of guarded languages (without continuations).

\begin{definition}
 Let $G: L + ♯ → I → 𝒞$ be a labeled family of guarded languages with continuations.
 We write $L\!↓$ for the (point-wise) least labeled family of guarded languages $G\!\downarrow$ such that the following rules are satisfied for all $k ∈ L + ♯$, $ℓ ∈ L$, and $i, j ∈ I$:
 \begin{mathpar}
  \inferrule{%
   w ⋅ \acc{i} ∈ Gᵢᵏ
  }{%
   w ∈ G\!↓ᵢᵏ
  }
  \and
  \inferrule{%
   w ⋅ \ret ∈ Gᵢᵏ
  }{%
   w ∈ G\!↓ᵢᵏ
  }
  \and
  \inferrule{%
   wα ⋅ \jmp{(ℓ, j)} ∈ Gᵢᵏ \\
   αx ∈ G\!↓ⱼ^ℓ
  }{%
   wαx ∈ G\!↓ᵢᵏ
  }
 \end{mathpar}
\end{definition}
The first two rules take care of flattening guarded words with continuations that in acceptance,
while the third rule strings together guarded words continuations that jump to a different label.

\begin{example}
 Let $G$ be the labeled family of guarded languages with continuations defined by
 \begin{align*}
  G₁^♯ & = \{ α ⋅ \jmp{(\ell, 1)} \}
    & G₂^♯ & = ∅ \\
  G₁^{\ell} & = \{ α p α ⋅ \jmp{(\ell', 1)}, β ⋅ \acc{1} \}
    & G₂^{\ell} & = \{ α ⋅ \jmp{(\ell', 2)} \} \\
  G₁^{\ell'} & = \{ α q α ⋅ \jmp{(\ell, 1)}, α r β ⋅ \jmp{(\ell, 1)} \}
    & G₂^{\ell'} & = \{ α ⋅ \jmp{(\ell, 1)}\}
 \end{align*}
 Now $G\!↓₁^♯$ contains, among other things,
 the guarded word $α p α q α p α r β$.

 Note furthermore that $G\!↓₂^{\ell}$ is empty, despite $G₂^{\ell}$ containing a guarded word with a continuation that has a mutual jump with another guarded word with continuation in $G₂^{\ell'}$, as these can never be concatenated into one guarded word with continuation of the form $\acc{i}$ or $\ret$.
\end{example}

In total, we can then obtain the semantics of a CF-GKAT term as $⟦ e ⟧\!\downarrow$, in the form of a labeled family of guarded languages.
This concludes our discussion of the semantics of CF-GKAT\@.

% FIXME: Do we need this here..?
\begin{lemma}\label{the: label missing causes empty semantics}
    If \(\comLabel{ℓ}\) does not appear in expression \(e\), then \(∀ i ∈ I, ⟦e⟧ᵢ^ℓ = ∅\).
\end{lemma}

% FIXME: I think this should be conversion to GKAT automaton
\section{Decision procedure}
\label{section:decision procedure}

To establish the decision procedure, we propose CF-GKAT automata, completing the classical correspondence between program, semantics, and automaton. 
Specifically, every CF-GKAT expression can be converted to a CF-GKAT automaton via the Thompson's construction, while preserving its continuation semantics. 

Unlike GKAT automata, directly performing bisimulation on CF-GKAT automata will not yield the desired trace equivalence. 
Indeed, there exist two programs with the same trace semantics but different continuation semantics:
\begin{mathpar}
  x := 1 \and \comAssert{\true}.
\end{mathpar} 
The first program sets the indicator variable to 1, and the second program simply skips. 
The trace semantics of the above two programs are the same, as both indicator assignment and skip are ``unproductive'', i.e. they will terminate immediately regardless of the input atoms and indicator variable.
Yet, their continuation semantics are different: \(⟦x := 1⟧ᵢ^♯\) will constantly emit the continuation \(\acc{1}\) regardless of \(i\), but \(⟦\comAssert{\true}⟧ᵢ^♯\) will preserve starting indicator by outputting the continuation \(\acc{i}\).

Thus, our decision procedure does not rely on bisimulation between CF-GKAT automaton; instead, we lower the CF-GKAT automata into GKAT automata. This process allows us to reuse the nearly-linear decision algorithm for GKAT automata equivalences.
Finally, the soundness and completeness of our decision procedure can be derived from a sequence of correctness results: first the correctness of Thompson's construction (\Cref{the:thompson-correctness}), second the correctness of the lowering (\Cref{the:cf-gkat-automaton-lowering-correctness}), and finally the soundness and completeness of GKAT automata equivalence~\cite{Schmid_Kappé_Kozen_Silva_2021}.

\subsection{GKAT automata}

In order to establish our decision procedure, we will first recap on GKAT automata and its trace semantics.
\begin{definition}[GKAT automata~\cite{Schmid_Kappé_Kozen_Silva_2021, kozen_BohmJacopiniTheorem_2008a}]
 A \emph{GKAT automaton} $A ≜ ⟨ S, δ, \hat{s} ⟩$ consists of a set of \emph{states} $S$, a \emph{transition function} $\delta: S → \At → ⊥ + ⊤ + Σ × S$, and a \emph{start state} $\hat{s} ∈ S$.
\end{definition}
Intuitively, the transition function of a GKAT automaton tells us, given a state $q$ and an atom $α$ accounting for the truth value of each primitive test, to either \emph{reject} the input, represented by $δ(q, α) = ⊥$, \emph{accept} the input, represented by $δ(q, α) = ⊤$, or to \emph{transition} to a new state in $S$ after executing an action from $Σ$, represented by $δ(q, α) ∈ Σ × S$.

A GKAT automaton induces a guarded language in a fairly straightforward manner.
\begin{definition}
 Given a GKAT automaton $A ≜ ⟨ S, δ, \hat{s} ⟩$, we define $⟦ - ⟧_A: S → 𝒢$ as the (pointwise) smallest function satisfying the following rules for all $s ∈ S$ and $α ∈ \At$:
 \begin{mathpar}
  \inferrule{%
   δ(s, α) = ⊤
  }{%
   α ∈ ⟦ s ⟧_A
  }
  \and
  \inferrule{%
   δ(s, α) = (p, s') \\
   w ∈ ⟦ s' ⟧_A
  }{%
   αpw ∈ ⟦ s ⟧_A
  }
 \end{mathpar}
 Finally, we define the guarded language semantics of $A$ by setting $⟦ A ⟧ = ⟦ \hat{s} ⟧_A$.
\end{definition}

Equivalence of finite GKAT automata is decidable, which we record as follows.
\begin{theorem}[Decidability for GKAT~\cite{Schmid_Kappé_Kozen_Silva_2021}]
 Given two finite GKAT automata $A₀$ and $A₁$, it is decidable whether they represent the same guarded language, i.e., whether $⟦ A₀ ⟧ = ⟦ A₁ ⟧$.
 The algorithm to do this has a complexity that is nearly-linear\footnote{$𝒪(\hat{α}(n))$, where $\hat{α}$ is the inverse Ackermann function; c.f.~\cite{Tarjan75}.} in the total number of states.
\end{theorem}

\subsection{CF-GKAT automata}

To leverage the efficient decision algorithm for GKAT automaton, we will need to convert each CF-GKAT expression $e$ into a GKAT automaton $A$ that implements $⟦ e ⟧\!↓$.
As we have discussed before, this process is separated into two steps, where we use CF-GKAT automaton as an intermediate between CF-GKAT expressions and GKAT automata. In this section, we will formally define CF-GKAT automata and their continuation semantics.

Like GKAT automaton, CF-GKAT automaton is defined by a dynamics, people familiar with universal coalgebra~\cite{rutten_UniversalCoalgebraTheory_2000,jacobs_IntroductionCoalgebraMathematics_2016} might recall that dynamics are also called the \emph{signature} of a coalgebra.
%FIXME: Do we want to keep using the name dynamics? I am not sure others use this name?
\begin{definition}[CF-GKAT dynamics]
 Given a set $X$, we write $G(X)$ for the set
 \[G(X) ≜ I × \At → ⊥ + C + Σ × X × I.\]
 %FIXME: I think we need to fix the code to follow this type
\end{definition}

Intuitively, the elements of \(G(S)\) represent possible transition behaviors in a CF-GKAT automaton over a state set $S$.
Given a current indicator value \(i ∈ I\) and an atom $α$ accounting for the truth value of each primitive test, a dynamic $ρ ∈ G(S)$ may either:
\begin{itemize}
 \item
       \emph{reject} the input, represented by $ρ(i, α) = ⊥$;
 \item
       offer a \emph{continuation}, represented by $ρ(i, α) ∈ C$; or
 \item
       execute a primitive action in $Σ$ and set a new indicator value from $I$ while transitioning to a new state in $S$, represented by $ρ(i, α) ∈ Σ × X × I$.
\end{itemize}

Then the definition of CF-GKAT automaton is similar to GKAT automaton, except we will need a function \(λ: L → G(S)\) where \(λ(ℓ)\) provides a dynamics representing the ``entry point'' for label \(ℓ\).
\begin{definition}
 A \emph{CF-GKAT automaton} \(A ≜ ⟨S, δ, \hat{s}, λ⟩\) consists of a set of \emph{states} \(S\), a \emph{transition function} \(δ: S → G(S)\),
 a \emph{start state} \(\hat{s} ∈ S\), and a \emph{jump map} \(λ: L → G(S)\).
\end{definition}

Intuitively, the transition map \(δ\) assigns every state in $S$ a dynamics from $G(S)$; the jump map $λ$, on the other hand, assign a dynamics for each label $ℓ ∈ L$, indicating how to resume the computation after a \(\jmp{ℓ}\) continuation is reached.
Dynamics in \(G(S)\) can then be assigned a continuation semantics in the CF-GKAT automaton \(A ≜ ⟨S, δ, ŝ, λ⟩\), as follows.

\begin{example}[A simple CF-GKAT automaton]
  Consider the following program \[\comITE{b}{\{\comLabel{ℓ}; p\}}{\comGoto{ℓ}},\] then we can construct the following automaton that have the same behavior as the program 
  %FIXME: probably better diagram?
  \[\begin{tikzcd}[row sep=small]
    {} & {\hat{s}} & s & {} \\
    & {} & {}
    \arrow[shorten <=8pt, from=1-1, to=1-2]
    \arrow["{\{b\}/p}", from=1-2, to=1-3]
    \arrow["∅"'{pos=1}, Rightarrow, from=1-2, to=2-2]
    \arrow["\{b\}"{pos=0.5}, shorten >=15pt, Rightarrow, from=1-3, to=1-4]
    \arrow["∅"'{pos=1}, Rightarrow, from=1-3, to=2-3]
  \end{tikzcd}\]
  where \(ŝ \xrightarrow{\{b\}/p} s\) means that \(δ(ŝ, i, \{b\}) = (s, p)\) and \(ŝ ⇒^∅\) means that \(δ(ŝ, i, ∅) = \acc{i}\).
  In the above automaton, where the start state is \(ŝ\), 
  \begin{itemize}
    \item If the input atom is \(\{b\}\), then it will transition to the state \(s\), while executing \(p\);
    then the state \(s\) will always accept.
    \item If the input atom is \(∅\), then it will simply accept the input without executing any action.
  \end{itemize}
  As we can see, the behavior of \(ŝ\) indeed matches the behavior of the program when executing from the start.
  Then the entry dynamics for \(ℓ\) can be defined as follows:
  \[λ(ℓ, i, α) ≜ (p, s, i).\]
  To put the above definition into words: when jump to the label \(ℓ\), we will reach the state \(s\) while executing \(p\); then \(s\) will halt regardless of the condition.
  Thus, the behavior of \(λ(ℓ)\) matches the behavior of the program when executing starting from the label \(ℓ\).
\end{example}

To formalize the intuition of ``behaviors'' in the previous example. We can assign a continuation semantics to each CF-GKAT automaton.

\begin{definition}[continuation semantics]
 Given an automaton \(A ≜ ⟨S, δ, \hat{s}, λ⟩\),
 the continuation semantics of each dynamics \(ρ ∈ G(S)\) is
 a family \(⟦ρ⟧_A: I → 𝒞\),
 defined as the (point-wise) smallest set satisfying the following rules for $i, j ∈ I$ and $α ∈ \At$:
 \begin{mathpar}
  \inferrule{%
   ρ(i, α) = \acc{j}
  }{%
   α ⋅ \acc{j} ∈ (⟦ρ⟧_A)ᵢ
  }
  \and
  \inferrule{%
   ρ(i, α) = \brk{j}
  }{%
   α ⋅ \brk{j} ∈ (⟦ρ⟧_A)ᵢ
  }
  \and
  \inferrule{%
   ρ(i, α) = \ret
  }{%
   α ⋅ \ret ∈ (⟦ρ⟧_A)ᵢ
  }
  \\
  \inferrule{%
   ρ(i, α) = \jmp{(ℓ, j)}
  }{%
   α ⋅ \jmp{(ℓ, j)} ∈ (⟦ρ⟧_A)ᵢ
  }
  \and
  \inferrule{%
   ρ(i, α) = (p, s, j) \\
   w ∈ (⟦δ(s)⟧_A)ⱼ
  }{%
   αpw ∈ (⟦ρ⟧_A)ᵢ
  }
 \end{mathpar}
 Similar to the continuation semantics of expressions, the continuations semantics of automata are also labeled families of guarded languages with continuations. Specifically, the semantics from the start \(⟦A⟧^♯\) is defined by the dynamics of the start state, and the semantics of a label \(ℓ ∈ L\) is defined by the jump map: 
 \begin{mathpar}
  ⟦ A ⟧^♯ = ⟦ δ( ŝ ) ⟧_A, \and 
  ⟦ A ⟧^ℓ = ⟦ λ(ℓ) ⟧_A \text{ for } ℓ ∈ L.
 \end{mathpar}
\end{definition}

\subsection{Lowering CF-GKAT automata to GKAT automata}\label{sec:lowering-cf-gkat-automata-to-gkat}

The process to lower a CF-GKAT automaton $⟨S, δ, \hat{s}, λ⟩$ into a GKAT automaton consists of two different components.
First, we "embed" the indicator values into the state set; the new state set then becomes $S × I$.
Second, we resolve all the continuations in transition results.
In particular, we need to resolve the jump continuations using the jump map $λ$: when $δ(s, i, α) = \jmp{(ℓ, j)}$, the $α$-transition leaving the state $(s, i)$ in the resulting GKAT automaton is determined by looking at the $α$-behavior starting from the label $ℓ$ with indicator value $j$, given by $λ(ℓ, j, α)$.

%FIXME: many \jmp(ℓ, i) still have ℓ and i in the wrong place. 
The main obstacle to properly resolve jump continuation is that $λ(ℓ, j, α)$ may itself point to a different label by returning $\jmp{(ℓ', k)}$, then \(λ(ℓ', k, α)\) may also yield a another jump, et cetera.
These jump sequences can be resolved by iterating the jump map, and terminate when either the result is no longer a jump, or a infinite loop is detected.

\begin{definition}[iteration lifting]\label{def: iteration lifting}
  Given a function \(h: X → X + ⊥ + E\), where \(X\) is a finite set
  and \(⊥ + E\) specifies the ``exit results'',
  then this function can be lifted to \(\iter(h)\) by iterating \(h\).
  We will use \(M\) to keep track of the explored value of \(M\):
  \begin{align*}
  \iter'(h) & : 2^X → X → ⊥ + E \\
  \iter'(h) & (M)(m) ≜ \begin{cases}
      ⊥ & \text{if } m ∈ M  \\
      h(m) & \text{if } m ∉ M \text{ and } h(m) ∈ ⊥ + E \\
      \iter'(h)(M ∪ \{m\})(h(m)) & \text{if } m ∉ M \text{ and } h(m) ∈ X
    \end{cases};
  \intertext{and \(\iter\) defined as supplying \(∅\) as the starting point of \(M\):}
    \iter(h) & : X → ⊥ + E \\
    \iter(h) & ≜ \iter'(h)(∅)
  \end{align*}
  To improve clarity, in the definition of \(h\),
  we will write \(\injL : X → X + ⊥ + E\) as \(\contWith\),
  to indicate the iteration will continue;
  and write \(\injR: ⊥ + E → X + ⊥ + E\) as \(\exitWith\),
  to indicate the iteration will be exited.
\end{definition}
Intuitively, \(M\) keeps track of all the explored value in \(X\),
and if a input has already been explored,
then rejection \(⊥\) will be returned to indicate a infinite loop;
as unproductive infinite iterations will not produce any observable trace.
Indeed, GKAT treats un-productive infinite iterations
in the \command{while} loops with the same strategy~\cite{Schmid_Kappé_Kozen_Silva_2021}.
On the other hand, if \(h(m)\) falls into the exit set \(⊥ + E\),
then \(\iter(h)\) will stop and return \(h(m)\).
Finally, if the \(h(m)\) fall into \(X\), then \(\iter(h)\) will continue the loop with \(h(m)\) as input, and mark \(m\) as explored.
Notice that \(\iter(h)\) will be total when \(h\) is total,
because \(X\) is a finite set.

In the specific case of jump resolution,
the iteration will continue when the result of \(λ\) is a jump, but exit otherwise.

\begin{definition}[Jump resolution]
 Let $S$ be a finite set, and let $λ∶ L → G(S)$ be a jump function.
 We define the resolved jump map ${λ\!↓}: L → G(S)$, as follows:
 \[
  λ\!↓ = \iter \left(
    (ℓ, i, α) ↦ \begin{cases}
      \contWith (ℓ', i', α) & λ(ℓ, i, α) = \jmp{(ℓ', i')} \\
      \exitWith (λ(ℓ, i, α)) & \text{otherwise}
    \end{cases}
  \right)
 \]
\end{definition}

Notice that \(λ\!↓\) resolves the internal jumps continuation in \(λ\); concretely the return of \(λ\!↓\) will never be a jump continuation. 
Intuitively, the continuation resolution is separated into two procedure: we first replace all the jump continuation with the dynamics \(λ\!↓\) to obtain \(δ'\), and then we will resolve the other continuation in \(δ'\) as both accept or reject to obtain the lowered transition function, namely \(δ\!↓\). Formally, the lowering is defined as follows:

\begin{definition}[Lowering CF-GKAT automata]
 Given a CF-GKAT automaton \(A ≜ ⟨S, δ, \hat{s}, λ⟩\), and $i ∈ I$, we define the GKAT automaton \({𝐴\!↓ᵢ} ≜ ⟨S × I, δ\!↓, (s, i)⟩\), where $δ\!↓$ is given in two steps:
 \begin{align*}
  δ'((s, i), α) & ≜
    \begin{cases}
      λ\!↓(ℓ, i, α) & δ(q, i, α) = \jmp{(ℓ, i)} \\
      δ(q, i, α) & \text{otherwise}
    \end{cases}\\
  δ\!↓((s, i), α) & ≜
  \begin{cases}
    % \mathrlap and \hphantom is used for alignment purpose
    % the \mathrlap is the displayed expression
    % and \hphantom contains the "longest expression" for alignment
    \mathrlap{⊥}\hphantom{λ\!↓(ℓ, i, α)} & δ'(s, i, α) ∈ \{ \brk{j} \}\\
   ⊤ & δ'(s, i, α) ∈ \{ \ret, \acc{j} : j ∈ I \} \\
   δ(q, i, α) & \text{otherwise}
  \end{cases}
 \end{align*}
\end{definition}
Notice \(λ\!↓\) is total and \(δ'((s, i), α)\) will not return a jump continuation, therefore $δ\!↓$ is well-defined; in other words, for all $s ∈ S$, $i ∈ I$ and $α ∈ \At$, it holds that $δ\!↓((s, i), α) ∈ ⊥ + ⊤ + Σ × (S × I)$, as expected for a GKAT automaton on state set $S × I$.

Having defined our lowering operation, we can state its correctness as follows.

\begin{theorem}[Correctness of lowering]\label{the:cf-gkat-automaton-lowering-correctness}
 Let \(A ≜ ⟨S, δ, \hat{s}, λ⟩\) be a CF-GKAT automaton.
 The translation from CF-GKAT automata to GKAT automata commutes with the semantic jump resolution operator, in the sense that for $i ∈ I$, it holds that $⟦A\!↓_i⟧ = ⟦A⟧\!↓^♯ᵢ$.
\end{theorem}

\subsection{Converting expressions to CF-GKAT automata}

The final piece of our puzzle is to convert CF-GKAT expressions to CF-GKAT automata.
To accomplish this, we generalize a construction proposed for GKAT, which turns a GKAT expression into a GKAT automaton in a trace-equivalent manner~\cite{Schmid_Kappé_Kozen_Silva_2021}.
This construction proceeds by induction on the structure of the expression and was inspired by Thompson's construction to obtain a non-deterministic finite automaton from a regular expression~\cite{thompson_ProgrammingTechniquesRegular_1968}, which is why we refer to it as the \emph{Thompson construction for CF-GKAT}.

In contrast to the original Thompson's construction, the Thompson's construction for GKAT produces a GKAT automaton with a \emph{start dynamics} instead of an explicit start state. 
Although automata with start dynamics are equivalent to automata with start states; using start dynamics will help us efficiently compose automata, avoiding the silent transitions present in the original algorithm.
To take advantage of start dynamics, we will define \emph{CF-GKAT automata with start dynamics} in the following definitions:

\begin{definition}
 A CF-GKAT automaton with start dynamics \(A ≜ ⟨S, δ, ι, λ⟩\) consists of $S$, $δ$ and $λ$ as in a CF-GKAT automaton, in addition to a start dynamics \(ι ∈ G(s)\).
\end{definition}

We elide the definition of the semantics for CF-GKAT automata with start dynamics for the sake of brevity.
Suffice it to say that they can be easily converted to a plain CF-GKAT automata by adding a start state \(\hat{s}\) that takes the start dynamics:
\begin{equation}\label{cons: CF-GKAT pseudo start to CF-GKAT automata}
 ⟨S, δ, ι, λ⟩ ↦ ⟨S + \hat{s}, δ_ι, \hat{s}, λ⟩,
 \text{ where }
 δ_ι(i, s, α) ≜
 \begin{cases}
  ι(i, α)    & \text{if } s = \hat{s} \\
  δ(s)(i, α) & \text{if } s ≠ \hat{s}
 \end{cases}
\end{equation}


% FIXME: The syntax in the expression column is the compact one... we probably want to change that - T
% FIXME: CZ: we don't have enough space, we need to think about this.
\begin{table}
  \centering
  \begin{tabular}{c || c | l | l | l}
   \(e\)  & \(S\) & \(δ(s): G(S)\) & \(ι(i, α): ⊥ + C + Σ × S × I\) & \(λ(ℓ): G(S)\) \\
   \hline
   \(\comAssert{b}\)& \(∅\)& \(!\)& \(
   \begin{cases}
    \acc{i} & (α, i) ∈ ⟦ b ⟧   \\
    ⊥       & \text{otherwise}
   \end{cases}
   \) & \(0\) \\
   %
   \(x := i'\) & \(∅\) & \(!\) & \(\acc{i}\) & \(0\) \\
   \(p\) & \(\{*\}\) & \(\acc{i}\) & \((p, *, i)\) & \( 0 \) \\
   \(\comRet\) & \(∅\) & \(!\) & \(\ret\) & \(0\) \\
   \(\comBrk\) & \(∅\) & \(!\) & \(\brk{i}\) & \(0\) \\
   \(\comGoto{ℓ}\) & \(∅\) & \(!\) & \(\jmp{(ℓ, i)}\) & \(0\) \\
   \(\comLabel{ℓ'}\) & \(∅\) & \(!\)  & \(\acc{i}\) &
    \((α, i) ↦ \begin{cases}
      \acc{i} & ℓ = ℓ' \\
      ⊥    & \text{otherwise}
     \end{cases}
   \)\\
   %
   \(e₁ +_b e₂\) & \(S₁ + S₂\) & \(
   \begin{cases}
    δ₁(s) & s ∈ S₁ \\
    δ₂(s) & s ∈ S₂
   \end{cases}
   \) & \(
   \begin{cases}
    ι₁(i, α) & (α, i) ∈ ⟦ b ⟧ \\
    ι₂(i, α) & (α, i) ∉ ⟦ b ⟧
   \end{cases}
   \) & \(
   \begin{cases}
    λ₁(ℓ) & \text{\(\comLabel{ℓ}\) in \(e₁\)} \\
    λ₂(ℓ) & \text{\(\comLabel{ℓ}\) in \(e₁\)} \\
    0 & \text{otherwise}
   \end{cases}
   \)\\
   %
   \(e₁ ⋅ e₂\) & \(S₁ + S₂\) & \(
   \begin{cases}
    δ₁(s)[ι₂] & s ∈ S₁ \\
    δ₂(s)      & s ∈ S₂
   \end{cases}
   \) & \( ι₁[ι₂](i, α) \) & \(
   \begin{cases}
    λ₁(ℓ)[ι₂] & \text{\(\comLabel{ℓ}\) in \(e₁\)} \\
    λ₂(ℓ) & \text{\(\comLabel{ℓ}\) in \(e₁\)} \\
    0 & \text{otherwise}
   \end{cases}
   \) \\
   %
   \({e₁}^{(b)}\)
   & \(S_{e₁}\)
   & \(⌊δ₁(s)[ι₁ᵇ]⌋\)
   & \(⌊ι₁ᵇ⌋(i, α)\)
   & \( ⌊ λ(ℓ)[ι₁ᵇ] ⌋ \) \\
  \end{tabular}
  %FIXME: CZ: I don't feel like we need a new notation 0
  \caption{Thompson's construction for CF-GKAT. Here,
  \(!\) denotes the unique function \(!: ∅ → X\) for any $X$,
  and $0$ denotes the constant rejection dynamics,
  i.e., $0(i, α) = ⊥$ for all $i ∈ I$ and $α ∈ \At$.}
  \label{tab: thompson's construction}
\end{table}

Thompson's construction turns a CF-GKAT expression \(e\) to a CF-GKAT automaton with start dynamics.
We call the result of said construction \emph{the Thompson's automaton} for \(e\).
The following paragraphs describe the construction and intuition behind Thompson's construction by cases, and \cref{tab: thompson's construction} serves as a summary; we will use \(A₁ ≜ ⟨S₁, δ₁, ι₁, λ₁⟩\) and \(A₂ ≜ ⟨S₂, δ₂, ι₂, λ₂⟩\) to denote the Thompson's automata for \(e₁\) and \(e₂\) respectively.
Finally, to obtain a CF-GKAT automaton with the same continuation semantics as \(e\), we will convert the Thompson's automaton of \(e\) to CF-GKAT automaton by construction \labelcref{cons: CF-GKAT pseudo start to CF-GKAT automata}.

%FIXME: CZ: I think all the following paragraphs should have formally defined the thompson's construction using notation. And the table should only be used as a reference.
% in this way we can make the table more compact.
\subsubsection*{Converting \comBrk, \comRet, \comGoto{ℓ}, and indicator assignment:}
recall the semantics of \(\comBrk\), \(\comRet\), \(\comGoto{ℓ}\), and indicator assignments will simply emit the corresponding continuations.
Thus, the Thompson's automata for these commands consist only of a start dynamic which yields the desired continuation.

\subsubsection*{Converting tests and primitive actions:}
the conversions of primitive tests and primitive actions largely inherit the Thompson's construction for GKAT.
The Thompson's automaton for tests \(b\) will contain only a start dynamic, which will accept the input indicator-atom pairs if and only if they satisfy \(b\).
The Thompson's automata for primitive actions \(p\) will contain a start dynamic that always transition to the unique state while executing the action \(p\), then the unique state will accept all inputs.

\subsubsection*{Converting labels:}
recall that \(\comLabel{ℓ'}\) is a non-operation when computing the semantics from the start of the program, i.e. its semantics coincides with the sequential identity: \(\comAssert{\true}\).
However, the behavior of \(\comLabel{ℓ'}\) and \(\comAssert{\true}\) diverges when we consider the semantics starting from labels.
Specifically, when starting from a label \(ℓ ≠ ℓ'\),
\begin{mathpar}
  ⟦\comLabel{ℓ'}⟧ᵢ^ℓ = ∅; \and
  ⟦\comAssert{\true}⟧ᵢ^ℓ = \{α ⋅ \acc{i} ∣ α ∈ \At \}.
\end{mathpar}
This difference is reflected in the jump map \(λ: L → G(S)\), which specifies the entry point for each label.
In this case, the jump map will map \(ℓ'\) to the behavior of the identity operation \(\comAssert{\true}\), and map every other label to constant rejection, representing that the continuation \(\jmp{ℓ}\) will not resume from \(\comLabel{ℓ'}\) when \(ℓ' ≠ ℓ\).

% FIXME: I think this is too on the nose... Basically just reiterating the definition
\subsubsection*{Converting \command{if} statements:}
the Thompson automaton for \(\comITE{b}{e₁}{e₂}\) is also similar to that of GKAT:
If the input atom-indicator pair satisfies \(b\), the start \(ι\) will enter the Thompson automaton of \(e₁\) by taking on the behavior of \(ι₁\) ; and when the starting atom-indicator pair doesn't satisfy \(b\), then \(ι\) will take on the behavior of \(ι₂\).
The jump map \(λ\) assigns the entry point for label \(ℓ\) based on where \(ℓ\) appears: namely if \(ℓ\) appears in \(e₁\), then \(ℓ\) will take its entry point in \(A₁\); and similarly, if \(ℓ\) appears in \(e₂\), \(ℓ\) will take its entry point in \(A₂\).

\subsubsection*{Converting Sequencing:}
Sequencing of automata can be defined by \emph{uniform continuations}, which combines two dynamics $h₁, h₂ ∈ G(S)$ into a new dynamic \(h₁[h₂]\): the resulting dynamic acts like $h₁$ in almost all cases, except when $h₁$ accepts, then it will take on the behavior of \(h₂\).
In other word, \(h₁[h₂]\) connects all the accepting transition of \(h₁\) to \(h₂\).
Uniform continuation is typically used to compose two automata or add self-loops to an automaton; and can be formally defined as follows.
\begin{definition}[Uniform Continuation]
  Let $S$ be a set and given two dynamic $h₁, h₂ ∈ G(S)$,
  their \emph{uniform continuation} is the dynamic $h₁[h₂] ∈ G(S)$, defined as follows:
  \[
    h₁[h₂](i, α) ≜
    \begin{cases}
    h₂(i', α) & \text{if } h₁(i, α) = \acc{i'} \\
    h₁(i, α)  & \text{otherwise}
    \end{cases}
  \]
\end{definition}
To construct the Thompson's automaton for \(e₁; e₂\),
we will simply connect all the accepting transition in \(A₁\) to \(A₂\),
by applying uniform continuations on start dynamics \(ι₁\), transitions \(δ₁\), and jump map \(λ₁\); while preserving the dynamics in \(A₂\).

\subsubsection*{Converting \command{while} loops:}

Like GKAT automata, CF-GKAT automata require every transition between states to execute a primitive action.
This characteristic presents a unique challenge in defining the start dynamics for while loops.
Namely, the primitive action is not necessarily encountered in the first iteration of the loop; for example, consider 
\begin{equation}\label[prog]{prog:loop-head-iter-example}
  \begin{aligned}
    \comWhile{ & x ≠ 2}{\{\\
      & \comITE{x = 0}{x := 1 \\
      &}{\comITE{x = 1}{\{p; x := 2\} \\
      &}{\{\comAssert{\true}\}}}\\ 
      \}}
  \end{aligned}
 \end{equation}
with the input indicator \(0\), then the first primitive action \(p\) will be encountered on the second iteration of the loop.
Even worse, when starting with an indicator variable that is not in \(\{0, 1, 2\}\), the program will be stuck in an infinite loop by the skip (written as \(\comAssert{\true}\)), and never encounter its first primitive action. 

Fortunately, these difficulties can be resolved by the \(\iter\) function (\cref{def: iteration lifting}). We will iterate the loop body until we encounter a primitive action or non-local control.
\begin{definition}[Iterated Start Dynamics]
  Let $S$ be a set, let $h ∈ G(S)$, and $b ∈ \BExp$.
  We can use the \(\iter\) function to define $hᵇ: G(S)$, as follows:
  \begin{align*}
   h^b & : G(S)\\
   h^b & ≜
   \iter\left(
     (i, α) ↦
     \begin{cases}
       \exitWith(\acc{i}) & \text{if } (i, α) ∉ ⟦b⟧ \\
       \contWith(i', α) & \text{if } (i, α) ∈ ⟦b⟧ \text{ and } h(i, α) = \acc{i'} \\
       \exitWith(h(i, α)) & \text{otherwise}
     \end{cases}
   \right)
  \end{align*}
\end{definition}
In the first case, the input \((i, a)\) doesn't satisfy \(b\), causing the while loop to terminate.
In the second case, the loop body accepts \((i, α)\) immediately and returns the exit indicator value \(i'\), thus the iteration of loop body will continue with \((i', α)\).
And the final case is reached when the program executes an action or encounters a non-local control, then the iteration can also be stopped.

\begin{example} 
  Consider the~\cref{prog:loop-head-iter-example} above with indicator set \(\{0, 1, 2, 3\}\), primitive action \(\{p\}\), no label, and no primitive boolean.
  Then the only atom is \(∅\), and thompson's automaton \(A₁ ≜ ⟨S₁, δ₁, ι₁, λ₁⟩\) for the loop body
  \begin{align*}
    & \comITE{x = 0}{x := 1 \\
    &}{\comITE{x = 1}{\{p; x := 2\} \\
    &}{\{\comAssert{\true}\}}}
  \end{align*}
  can be computed to be following
  \[
    S₁ ≜ \{s\} \qquad 
    \begin{aligned}
      ι₁(0, ∅) & ≜ \acc{1}\\
      ι₁(1, ∅) & ≜ (p, s, 2)\\
      ι₁(2, ∅) & ≜ \acc{2}\\
      ι₁(3, ∅) & ≜ \acc{3}
    \end{aligned} \qquad
    \begin{aligned}
      δ₁(s, 0, ∅) & ≜ \acc{0}\\
      δ₁(s, 1, ∅) & ≜ \acc{1}\\
      δ₁(s, 2, ∅) & ≜ \acc{2}\\
      δ₁(s, 3, ∅) & ≜ \acc{3}
    \end{aligned} \qquad
    λ ≜ {!}
  \]
  where \(λ ≜ {!}\) is the unique function \(∅ → G(S₁)\), since the label set is empty.
  %FIXME: this derivation does not exactly follow the definition of iter, but a intuitive account
  Then the iterated start dynamics \(ι^{x≠2}\) with starting indicator \(0\) can be computed as follows:
  \begin{align*}
    ι₁^{x≠2}(0, ∅) 
    & = ι₁^{x≠2}(1, ∅) 
      & \text{because }(0, ∅) ∈ ⟦x ≠ 2⟧ \text{ and } ι₁(0, ∅) = \acc{1} \\  
    & = (p, s, 2)
      & \text{because } ι₁(1, ∅) = (p, s, 2) \\
    ι₁^{x≠2}(3, ∅) 
    & = ι₁^{x≠2}(3, ∅) 
      & \text{because }(3, ∅) ∈ ⟦x ≠ 2⟧ \text{ and } ι₁(3, ∅) = \acc{3} \\  
    & = ⊥
      & \text{because the input \((3, ∅)\) is already explored}
  \end{align*}
\end{example}

With the start dynamics defined, we still need to resolve structures within the loop body, like the \(\comBrk\)-continuation.
To perform $\comBrk$-resolution, we extend the \(⌊-⌋\) operator to dynamics.
\begin{definition}
Let $S$ be a set, and let $h ∈ G(S)$.
We define $⌊h⌋ ∈ G(S)$ by lifting \(h\) via \(⌊-⌋\) when it returns a continuation:
\[
  ⌊h⌋(i, α) = \begin{cases}
  ⌊h(i, α)⌋ & \text{if } h(i, α) ∈ C \\
  h(i, α)   & \text{otherwise}
  \end{cases}
\]
\end{definition}

Finally, the transition function \(δ\) and jump map \(λ\) can be defined by first connecting \(δ₁\) and \(λ₁\) back to start dynamics \(ι\), forming a loop in the automaton;
then resolving the \(\brk{i}\) continuations using the break resolution function \(⌊-⌋\).

% FIXME: we need an example here, based on the unproductive loop shown above - T


% FIXME: I think this is good to say, but should be in a separate remark after the construction is fully presented - T
% In the worst case, it is possible for \(I'\)
% to exhaust all of \(I\) before an infinite loop is found,
% which means computing \(γ\) can take \(|I|\) time
% for every indicate \(i\) and atoms \(α\).
% However, for a fixed atom \(α\), we can cache the result of each \(i\),
% leading to a \(|I|\)-timed algorithm to compute \(γ\) for every input \(i\).



With the Thompson's construction defined, we can state the correctness of the Thompson's construction as follows.
\begin{theorem}\label{the:thompson-correctness}
 Let $e ∈ \CFGKAT$, and let $A$ be the Thompson automaton for $e$.
 Then for all $ℓ ∈ L$ we have that $⟦A⟧ = ⟦e⟧^♯$ and $⟦λₑ(ℓ)⟧_A = ⟦e⟧^ℓ$.
\end{theorem}

\subsection{Algorithm and Complexity}


\section{Control Flow Verification}

% Our theory can be specialized into control flow verification in two different way: first, we can decide the equivalence between a program with a flowchart, where the flowchart is represented by a GKAT automaton; second, we can directly decide the equivalence between to programs.

We hypothesize that CF-GKAT can be a useful tool to check whether two programs have the same control flow, i.e.:\ under the same circumstances, they execute the same sequence of primitive commands.
An example use case could be to validate the correctness of refactoring operations aimed at making code more readable by eliminating or introducing early loop termination.
In general, this type of validation will never be \emph{complete}, as it cannot automatically validate the correctness of refactorings that introduce or eliminate primitive commands, even when this produces a functionally equivalent program.
However, CF-GKAT should be applicable to refactoring operations that rearrange the code for the sake of improving the presentation of the control flow.

Another use case would be to validate the \emph{control flow structuring} stage found in modern decompilers.
Briefly put, a decompiler is a program tasked with inferring a high-level language representation of a binary executable file.
In earlier stages, the decompiler builds a \emph{control-flow graph} from the binary, in which the vertices represent different blocks of instructions, and the edges encode how control may transfer from the end of one block to the beginning of the other.
The control flow structuring pass is tasked with inferring an equivalent representation of this control flow graph in terms of constructs like \command{if-then-else} and \command{while-do}.
A tool that validates the output of a control flow structuring algorithm could leverage CF-GKAT, by casting the control flow graph as a GKAT automaton, and comparing that to the GKAT automaton that corresponds to the inferred program.

In this section, we test our hypotheses on the applicability and efficiency of CF-GKAT\@.
We start by describing our implementation of the proposed decision procedure.
Next, we report on experiments with workloads that reflect the two use cases described above.
