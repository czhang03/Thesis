\chapter{Domain Reasoning In TopKAT}
\label{chapter:TopKAT}
\thispagestyle{myheadings}

\section{Motivation and Overview}

% 1 - Program logics are a fundamental tool for program reasoning
% 2 - Hoare logic have guided the development of formal reasoning frameworks
% 3 - KAT subsumes Hoare Logic
% 4 - Incorrectness Logic is a new deductive logic for reasoning about programs
% 5 - Can we encode Incorrectness Logic in KAT
% 6 - We show that this is not possible
% 7 - We consider TopKat and show that we can encode incorrectness triples in it
% 8 - We consider Fail top kat for reasoning about failure
% 9 - We study the relation among different models. 

Since the seminal work of \citet{Floyd67} and \citet{Hoare69}, logic has become
an essential tool for program verification.  A program logic provides a system
of \emph{deduction rules} to prove \emph{Hoare triples} \(\hoareTriple{b}{p}{c}\),
where \(p\) is a program, and \(b\) and \(c\) are assertions describing the pre-
and post-conditions.  Such Hoare triples are (partial) correctness
specifications, which state that, if we run \(p\) on an initial state satisfying
\(b\), all the final states (if reached) will satisfy \(c\). In other words, \(c\)
\emph{over-approximates} the set of final states of \(p\) starting from \(b\). 

Despite their popularity, \emph{equational reasoning}, like Kleene Algebra with Tests has also prevailed in parallel.
The two approaches turned out to be not so different. \citet{Kozen_2000}
showed that KAT can express the validity of a Hoare triple as an equation, in
such a way that the deduction rules of a large fragment of Hoare Logic can be
obtained by equational reasoning.  \citeauthor{Kozen_2000}'s work
established a clear bridge between deductive and equational reasoning for
program verification, thus shedding light on the expressive power of KAT\@.

In this work, we are interested in extending this correspondence to other
deductive formalisms for reasoning about programs.  One such formalism is
\emph{incorrectness logic} (IL), a recent proposal
by~\citet{OHearn_2020} that relates to earlier works
by~\citet{devries_ReverseHoareLogic_2011}. 
Instead of correctness, as in the Floyd-Hoare tradition, the system
revolves around \emph{incorrectness specifications} of the form
\(\incorTriple{b}{p}{c}\), which state that \(p\) can produce \emph{any} final
state satisfying \(c\) from \emph{some} input state satisfying \(b\)---or,
equivalently, that \(c\) \emph{under-approximates} the set of final states of
\(p\) starting from \(b\).  Though less conventional than traditional Hoare
logic, incorrectness logic has already found its way to several applications,
such as variants of separation logic~\cite{Raad_Berdine_Dang_Dreyer_OHearn_Villard_2020} 
and relational verification for noninterference~\cite{murray_UnderApproximateRelationalLogic_2020a}.

\begin{figure}
    \centering
    \begin{tikzcd}[row sep=5em, column sep=10em, math mode = false]
        \FailTopREL \arrow[r, two heads, 
            "\Cref{the: FailTopKAT can express incorrectness logic}"]
        & \text{IL} \\
        \TopREL \arrow[r, two heads, 
            "\Cref{the: topkat can express incorrectness logic normal termination}"]
        & \text{codomain inclusion} 
            \arrow[d, "defines"description]
            \arrow[dd, bend left=90, "defines"description]\\
        \TopGREL \arrow[d, leftrightarrow, "\Cref{the: TopGREL expressive power} (equiexpressive)"' ]
            \arrow[r, "/" marking, two heads, "\Cref{the: TopGREL expressive power}"]
        &  \text{IL (without errors)} \\
        \REL \arrow[r, two heads, "\cite{Kozen_2000}"']
            \arrow[ur, "/" marking, two heads, "\Cref{the: KAT not able to express incorrectness logic}"']
        & \text{HL} 
    \end{tikzcd}
    \caption{Expressiveness of different systems.}\label{fig:expressiveness-of-different-kat}
\end{figure}

It is natural to wonder whether \citeauthor{Kozen_2000}'s idea could be
adapted to encode incorrectness logic in Kleene algebra with tests.
Unfortunately, this is not the case. As we will show in this thesis, there are
incorrectness triples that cannot be expressed by any KAT equation.  This might
appear surprising, given the symmetry between over- and under-approximation in
the formulation of Hoare logic and incorrectness logic.  However, the symmetry
involves the \emph{image} of a set by a relation, an operation that is not part
of the syntax of KAT\@.  Several prior works have considered enlarging KAT with
similar
operations~\cite{Desharnais_Möller_Struth_2004,Fahrenberg_Johansen_Struth_Ziemiánski_2021,Desharnais_Möller_Struth_2006},
but we show here that a smaller extension also serves our purposes: namely,
adding a top element \(\top\) to KAT\@.   We call such a structure a \emph{Kleene
  algebra with tests and top}, or a TopKAT\@.  We show that such structures can
encode inequalities between images, which we use to express incorrectness
triples.  The encoding allows us to prove the rules of incorrectness logic
equationally, thus extending \citeauthor{Kozen_2000}'s correspondence to
incorrectness reasoning. In fact, the use of TopKAT to encode incorrectness logic was also hinted in the original incorrectness logic paper~\cite{OHearn_2020}.

For clarity of exposition, our main focus is on the fragment of incorrectness
logic that handles normal program termination.  However,
\citet{OHearn_2020} also considered triples of the form
\([p]\, c\, [er: q]\), whose interpretation is similar to the one we described
above, except that they assume that execution can terminate with a fatal error
(e.g.\ a failed assertion).  Following \citet{Mamouras_2017}, we show
that our encoding carries over to such triples by considering FailTopKAT, an
extension of TopKAT that includes an element \(\fail\) for representing failure.
We prove that the abnormal termination rules of incorrectness logic follow from
the equations of FailTopKAT\@.

We summarize our encodings in \Cref{fig:expressiveness-of-different-kat}.  We
use the notation \(A ↠ B\) to mean that the logic \(B\) can be
expressed in the equational theory of \(A\).  More formally, we model the
ground-truth notion of validity in each logic as a statement about sets
(assertions about program states) and relations (the input-output graph of a
program).  The encodings show that such statements are equivalent to equations
involving operations in \emph{relational} algebraic structures, where the
carrier of the structure is some set of relations between program states (for
example, \(\FailTopREL\) is the class of relational FailTopKATs in
\Cref{def:relational-failtopkat}).  Moreover, we prove that the equational
theory alone (i.e., not specialized to relations) suffices to derive the rules
of each logic.  We also use the arrow \(\to\) to denote the fact that 
systems capable of expressing codomain can express both Hoare logic and incorrectness logic.

\aaa{The explanation about the \(\to\) notation in
  \Cref{fig:expressiveness-of-different-kat} seems a bit ad hoc.}

\begin{figure}
    \centering
    \begin{tikzcd}[math mode = false, row sep=4em, column sep=9em]
        & \TopREL \arrow[d, "/" marking, "incomplete"'near start, 
        "\Cref{the: topkatstar incomplete over relational model}"near start]
        & \\
        \TopGREL \arrow[r, "complete", "\Cref{the: general relational TopKAT for free}"']
        & \TopKAT & 
        \text{language \TopKAT} \arrow[l, "complete"', "\Cref{the: language TopKAT for free}"] \\
        \REL \arrow[r, "complete", "\cite{Kozen_1997}"'] & 
        \KAT & 
        \text{language \KAT} \arrow[l, "complete"', "\cite{Kozen_1997}"]
    \end{tikzcd}
    \caption{Completeness relationships between classes of Kleene Algebras with Tests.}\label{fig:completeness}
\end{figure}

To evaluate the usefulness of these encodings, we investigate two basic
properties of TopKAT\@: \emph{completeness} and \emph{decidability}.  We say
that an equational theory is complete for a certain class of structures if it
can derive any equation that is valid in the class.  We are particularly
interested in completeness with respect to relational structures, since they are
the natural setting for formulating program logics. 
However, it is well-known that the addition of a top element can be problematic for completeness of relational structures~\cite{pousAutomataRelationAlgebra2016}, and we show that this is the case for TopKAT as well: the theory is incomplete for \(\TopREL\), the class of relational structures where the top element is the complete relation.  
However, we were able to obtain (co)domain completeness: all (co)domain comparison inequalities, which subsumes both the encoding of incorrectness logic and Hoare logic, are derivable if and only if they are true in relational model. Setting a solid foundation for reasoning about program logic using KAT.

The (co)domain comparison result is built upon several lower-level completeness result. Specifically, the completeness regarding language TopKAT, which naturally induces the completeness of general relational TopKAT (\TopGREL), a larger class of TopKAT where the elements are relations.
Given the relational nature of TopGREL, it is natural to wonder if we can encode incorrectness logic in it. However, we have shown that it is impossible: every predicate that is encodable in TopGREL is already encodable in relational KAT.
All of the above completeness results and equi-expressiveness results are simple corollaries of our new structured version of reduction~\cite{Pous_Rot_Wagemaker_2021}, where instead of relating relating both the language model and the theory, we characterize the reduction simply as an injective interpretation.

\section{Preliminary on Program Logics}

\subsection{Hoare Logic}\label{sec:incorrectness-and-hoare}

Hoare logic is a fundamental tool for specifying and proving the correctness of
while-like programs. Following \citet{Kozen_2000}, we consider here
\emph{propositional Hoare logic}, which involves partial correctness Hoare
triples \(\hoareTriple{b}{p}{c}\) consisting of atomic propositions,
propositional connectives and while-like programs.  As usual, a Hoare triple
\(\hoareTriple{b}{p}{c}\) means that if the program \(p\) terminates when run on
a memory satisfying \(b\), it will result in a memory satisfying \(c\).
\Cref{fig:HL} shows the rules of propositional Hoare logic, which differ from
the classical setting in their omission of the assignment rule.


\begin{figure}
    \begin{mathpar}
        \inferrule[Composition]
        {\hoareTriple{a}{p}{b} \\ \hoareTriple{b}{q}{c}}
        {\hoareTriple{a}{p;q}{c}}
    
        \and 
        \inferrule[Conditional]
        {\hoareTriple{b\land c}{p}{d} \\ \hoareTriple{\neg b\land c}{q}{d}}
        {\hoareTriple{c}{\comITE{b}{p}{q}}{d}}

        \and
        \inferrule[While]
        {\hoareTriple{b\land c}{p}{c}}
        {\hoareTriple{c}{\comWhile{b}{p}}{\neg b\land c}}

        \and
        \inferrule[Consequence]
        {b' → b \\ \hoareTriple{b}{p}{c} \\ c → c'}
        {\hoareTriple{b'}{p}{c'}}

      \end{mathpar}
      \caption{proof rules of propositional Hoare logic}\label{fig:HL}
\end{figure}

In its essence, Hoare logic is an \emph{over-approximation} logic.  To see this,
it is convenient to think about a program \(p\) as a relation between input
memories and output memories, and to think about predicates \(b\) and \(c\) as
sets of states.  Given a program \(p\) and a predicate \(b\), we can write
\(\post(p)(b)\) for the set of post-states, that is
%
\[\post(p)(b)=\{ x \mid \exists y\in b, (y,x)\in p \}.\]
%
A partial-correctness Hoare triple \(\hoareTriple{b}{p}{c}\) is valid
iff \[\post(p)(b) \subseteq c.\] In words, \(c\) over-approximates the set of
memories which can be obtained from \(b\) by running the program \(p\).  This
condition can be expressed by means of the codomain of a relation: if we set
\[\cod(r) ≜ \{y \mid \exists x \in X, (x, y) \in r\},\]
then, for all a relational KAT \((ℛ, ℬ)\), 
\(b, c \in ℬ\) and \(p \in ℛ\),
\[\hoareTriple{b}{p}{c} ≜ \cod(b p) \subseteq \cod(c).\]


\citet{Kozen_2000} showed that we can reason about the 
partial correctness of propositional Hoare logic in KAT\@. 
To do this  we can use tests to represent pre and post-conditions,
thus encode a partial correctness propositional Hoare triple
\(\hoareTriple{b}{p}{c}\) as the KAT equality:
\[b p \overline{c} = 0, \text{ or equivalently, } b p = b p c.\]

Indeed, we can show that in all relational KATs \((ℛ, ℬ)\) and
\(p \in ℛ, b, c \in ℬ\),
\[\hoareTriple{b}{p}{c} \iff bp = bpc \iff b p \overline{c} = 0.\]
Given that KAT is complete over relational KAT, we can determine the relational
validity of some propositional Hoare triples by the equational theory of KAT\@.

\subsection{Incorrectness Logic}
% The formulation provided by \citet{Kozen_2000} turns out to be very useful 
% in reasoning about program correctness using equational theory of KAT;
% but what if the given program is incorrect? 
%
\citet{OHearn_2020} proposed incorrectness logic to reason about
incorrect programs.  This logic is also related to earlier works by
\citet{devries_ReverseHoareLogic_2011}.  Like Hoare logic, incorrectness logic is built on
triples of the form \(\incorTriple{b}{p}{c}\), which denote \emph{incorrectness
  specifications}, where \(c\) is a set of undesirable final states and \(b\) is a
precondition. Intuitively, such a triple says that every memory in \(c\) needs
to be reachable from \(b\) by executing \(p\).

\begin{figure}
    \begin{mathpar}
        \inferrule[Empty]
        {\\}{\incorTriple{b}{p}{\gamma: ⊥}}

        \and
        \inferrule[Consequence]
        {b → b' \\ \incorTriple{b}{p}{\gamma: c} \\ c' → c}
        {\incorTriple{b'}{p}{\gamma: c'}}

        \and
        \inferrule[Disjunction]
        {\incorTriple{b_1}{p}{\gamma: c_1} \\ \incorTriple{b_2}{p}{\gamma: c_2}}
        {\incorTriple{b_1 \lor b_2}{p}{\gamma: (c_1 \lor c_2)}}

        \and
        \inferrule[Identity]
        {\\} {\incorTriple{b}{\comSkip}{\okState: b, \errState: 0}}

        \and
        \inferrule[Composition-Fail]
        {\incorTriple{a}{p}{\errState: b}}
        {\incorTriple{a}{p;q}{\errState: b}}

        \and
        \inferrule[Composition-Normal]
        {\incorTriple{a}{p}{\okState: b} \\ \incorTriple{b}{p}{\gamma: c}}
        {\incorTriple{a}{p;q}{\gamma: c}}

        \and
        \inferrule[Choice-Left]
        {\incorTriple{b}{p}{\gamma: c}}
        {\incorTriple{b}{p + q}{\gamma: c}}

        \and
        \inferrule[Choice-Right]
        {\incorTriple{b}{q}{\gamma: c}}
        {\incorTriple{b}{p + q}{\gamma: c}}

        \and
        \inferrule[Assume]
        {\\}
        {\incorTriple{a}{\comAssert{b}}{\okState: a \land b, \errState: 0}}

        \and
        \inferrule[Error]
        {\\}{\incorTriple{b}{\fail}{\errState: b}}

        \and
        \inferrule[Iter-Zero]
        {\\}{\incorTriple{b}{{p}^*}{\okState: b}}

        \and
        \inferrule[Iter-NonZero]
        {\incorTriple{b}{{p}^*;p}{\gamma: c}}
        {\incorTriple{b}{{p}^*}{\gamma: c}}

        \and
        \inferrule[Iter-Dependent]
        {∀ n ∈ ℕ,~ \incorTriple{b(n)}{p}{\okState: b(n+1)}}
        {\incorTriple{b(0)}{{p}^*}{\okState: \exists n, b(n)}}
    \end{mathpar}
    \caption{Generic incorrectness logic proof rules~\cite{OHearn_2020}}\label{fig: orignal proof rules of inc logic}
\end{figure}

If Hoare logic is an ``over-approximation'' logic, incorrectness logic is an
``under-approximation'' logic: an incorrectness triple \(\incorTriple{b}{p}{c}\)
is valid if and only if
\[\post(p)(b) \supseteq c.\]

In other words, the post-condition \(c\) ``under-approximates'' the canonical
post condition of \(b\) after executing \(p\).
When we only look at program that terminates normally, 
the previous definition can be expressed in relational KAT as 
\[\cod(bp) \supseteq \cod(c).\]
As mentioned by \citet{OHearn_2020},
the definitions of incorrectness and Hoare triples are highly symmetric:
\begin{align*}
    \hoareTriple{b}{p}{c} & ≜ \cod(b p) ⊆ \cod(c) \\
    \incorTriple{b}{p}{c} & ≜ \cod(b p) ⊇ \cod(c)
\end{align*}

Since incorrect programs often lead to explicit errors,
\citet{OHearn_2020} also considered incorrectness triples
\(\incorTriple{b}{p}{\errState: c}\), which mean that, in addition to satisfying
$c$, we require that the final states of $p$ lead to an error.  More generally,
we use the notation $\incorTriple{b}{p}{γ: c}$, where the \emph{error
  code} \(γ ∈ \{\okState, \errState\}\) signals whether the program
terminated normally or not; hence, the unqualified notation
\(\incorTriple{b}{p}{c}\) is simply a shorthand for
\(\incorTriple{b}{p}{\okState: c}\), when abnormal termination is not a
concern. Informally, such general triples mean that
\[\incorTriple{b}{p}{\gamma: c} ≜ \cod(b p) \supseteq \cod((\gamma: c)).\]
In \Cref{sec: failkat and error}, we will give a more concrete definition of
this semantics in an extension of KAT\@.

The generic proof rules of incorrectness logic are listed in \Cref{fig: orignal
  proof rules of inc logic}.
Following \citet{OHearn_2020}, we formulate
incorrectness logic for a language of commands which is essentially
the same of KAT terms. Conditionals and loops as their embedding from GKAT~\cite{Kozen_2000,Smolka_Foster_Hsu_Kappé_Kozen_Silva_2020}, which we will recall here:
\begin{align*}
    \comITE{b}{p}{q} & ≜  (\comAssert{b};p) + (\comAssert{\overline{b}}; q) \\
    \comWhile{b}{p} & ≜ {(\comAssert{b}^*; p)} ;\comAssert{\overline{b}}
\end{align*}
Following \citet{OHearn_2020}
we also use
\(\incorTriple{b}{p}{\okState: c_1, \errState: c_2}\) as a shorthand for two
different rules. For example, the rule
\begin{mathpar}
    \inferrule[Unit]
    {\\}{\incorTriple{a}{1}{\okState: a, \errState: 0}}
\end{mathpar}
stands for the two rules
\begin{mathpar}
    \inferrule[Unit-Ok]
    {\\}{\incorTriple{a}{1}{\okState: a}}

    \inferrule[Unit-Er]
    {\\}{\incorTriple{a}{1}{\errState: 0}}.
  \end{mathpar}
The fragment of incorrectness logic we consider here is \emph{propositional} in the sense of \citet{Kozen_2000}. In particular, this presentation omits  rules for variables and mutation~\cite{OHearn_2020}. 

\section{Formulating Incorrectness Logic}\label{sec: formulating incorrectness logic}

We might hope that the symmetry between Hoare logic and incorrectness logic
would help us express incorrectness triples by adapting the formulation of
\citet{Kozen_2000}. However,
it is not obvious how we can exploit this symmetry, since it involves the
codomain operation, which does not appear in the formulation of
\citet{Kozen_2000}.  
This difficulty, unfortunately, is fundamental: KAT cannot express
incorrectness logic.

\begin{definition}\label{def: relational validity of incorrectness triple}
  Given a relational KAT \((ℛ, ℬ)\), \(p \in ℛ\)
  and \(b, c ∈ ℬ\), an Incorrectness Triple
  \(\incorTriple{b}{p}{c}\) is \emph{valid} with respect to
  \((ℛ, ℬ)\), denoted
  \((ℛ, ℬ) ⊧ \incorTriple{b}{p}{c}\), if
  \[\cod(bp) ⊇ \cod(c)\]
  we consider the predicate of incorrectness triple:
  \(inc(b, p, c) ≜ \incorTriple{b}{p}{c}\).  We write \(inc\) over
  primitive tests \(b, c\) and primitive action \(p\) as
  \(\incorTriple{b}{p}{c}\).
\end{definition}

To show that incorrectness triple cannot be formulated using equality of KAT
terms, we only need to show that \(\incorTriple{b}{p}{c}\)
cannot be expressed in \(\REL\).  More explicitly, we need to show that for
all \(K, B\) where \(p ∈ K\) and \(b, c ∈ B\), there
does \emph{not} exist a pair of terms
\(e₁, e₂ ∈ \KAT_{K, B}\) s.t.\ for all relational
Interpretation \(I\):
\[I(e₁) = I(e₂) ⟺ \incorTriple{I(b)}{I(p)}{I(c)}\] 
To prove such a pair of expressions don't exist, we will first establish some lemmas,
which will help us narrow down our goal.

\begin{lemma}[redundancy of alphabet]\label{the: redundancy of alphabet}
    If for some \(K, B\) where \(p ∈ K\) and \(b, c ∈ B\), 
    and a pair of terms \(e_1, e_2 ∈ \KAT_{K, B}\),
    that for all relational KAT interpretations \(I: \KAT_{K, B} → ℛ\),
    \[I(e_1) = I(e_2) ⟺ \incorTriple{I(b)}{I(p)}{I(c)}\]
    then there exist \(\hat{e_1}, \hat{e_2} ∈ \KAT_{\{p\},\{b, c\}}\) 
    such that, for every relational interpretation \(I': \KAT_{\{p\}, \{b, c\}} → ℛ\), 
    \[I'(\hat{e_1}) = I'(\hat{e_2}) ⟺ \incorTriple{I(b)}{I(p)}{I(c)}\]
\end{lemma}

\begin{proof}
    We define the following interpretation \(\hat{(-)}: \KAT_{K, B} → \KAT_{\{p\}, \{b, c\}}\) by lifting the following action on the primitives:
    \begin{align*}
        \hat{p'} & = p & p' ∈ K \\  
        \hat{b'} & = \begin{cases}
            c & b' ≠ b \\  
            b & b' = b
        \end{cases} 
    \end{align*}
    Notice that this definition preserves the primitives \(p, b, c\):
    \begin{mathpar}
        \hat{p} = p \and \hat{c} = c \and \hat{b} = b
    \end{mathpar}
    Because \(I' ∘ \hat{(-)}: \KAT_{K, B} → ℛ\) is a interpretation, by the premise, we obtain our conclusion,
    \[I'(\hat{e_1}) = I'(\hat{e_2}) ⟺ \incorTriple{I'(b̂)}{I'(p̂)}{I'(ĉ)} ⟺ \incorTriple{I'(b)}{I'(p)}{I'(c)}. \qedhere\]
\end{proof}

Thus, in order to show that there does not exist a pair of terms
\(e_1, e_2 ∈ \KAT_{K,B}\) to express incorrectness logic,
we only need to show that there does not exist
\(\hat{e_1}, \hat{e_2} ∈ \KAT_{\{p\},\{b, c\}}\) 
that are capable of formulating incorrectness logic.


\begin{lemma}\label{the: only one action var}
    Given a expression \(e ∈ \KAT_{\{p\}, \{b, c\}}\)
    and a relational KAT interpretation \(I\) with \(I(p) = ∅\), if
    \((x, y) ∈ I(e)\), we have \(x = y\).
\end{lemma}

\begin{proof}
    By induction on the structure of \(e\).
\end{proof}

\begin{lemma}\label{the: KAT inccorrectness logic core lemma}
    Given a expression \(e ∈ \KAT_{\{p\},\{b, c\}}\)
    and a relational KAT interpretation \(I\), if \((x, y) ∈ I(e)\),
    then either:
    \begin{itemize}
    \item there exist \(z\) and \(z'\) such that \((x, z) ∈ I(p) \text{ and } (z', y) ∈ I(p)\); or
    \item \(x = y\) and \((x,y) ∈ I_∅(e)\), where the interpretation \(I_{∅}\) is lifted by the following action on primitives:
    \[I_{∅}(p') ≜ \begin{cases}
        ∅ & p' = p \\  
        I(p') & \text{otherwise}
    \end{cases}\]
\end{itemize}
\end{lemma}

\begin{proof}
    Intuitively, this lemma states
    if the element \((x, x)\) is generated by purely by some tests 
    in \(I(e_2)\),
    then we can ignore all the action variables in the expression by setting it to \(∅\).
    Otherwise, \((x, x)\) must be generated by composing some actions together,
    since tests only \emph{filters out} elements when composed 
    and cannot generated new elements.
    Thus we will need at least a action to start with \(x\), 
    and a action to end with \(x\).
    
    This lemma can be proven by induction on the structure of \(e\): 
    \begin{itemize}
        \item If \(e\) is an element of the alphabet, i.e. \(e = p\), \(e = b\), or \(e = c\).
        \begin{itemize}
        \item If \(e = p\), then \((x, y) ∈ I(e)\) 
            iff \((x, y) ∈ I(p)\)
            thus, we can have \(z = y, z' = x\), hence 
            \[(x, z) ∈ I(p)  \text{ and }  (z', y) ∈ I(p)\]
        \item If \(e = b\) or \(e = c\),
            then the interpretation of \(p\) will not matter, 
            hence assigning \(p\) to empty will also contain \((x, y)\).
            Therefore \((x, y) ∈ I_∅(e)\).
            And by \Cref{the: only one action var}, \(x = y\)
        \end{itemize}
        \item If \(e\) is of the form \(e_1 + e_2\),
        then 
        \begin{align*}
            (x, y) ∈ I(e_1 + e_2)
            & ⟹ (x, y) ∈ I(e_1) ∪ I(e_2) \\
            & ⟹ (x, y) ∈ I(e_1) \text{ or } (x, y) ∈ I(e_2)
        \end{align*}
        Without loss of generality, assume \((x, y) ∈ I(e_1)\).
        Then by induction hypothesis, we have 
        \begin{itemize}[nosep]
            \item either \(I_∅(e_1)\) and \(x = y\)
            \item or \(∃ z, z', \text{ s.t. } (x, z), (z', y) ∈ I(p)\)
        \end{itemize}
        Because \(I_∅(e) = 
        I_∅(e_1 + e_2) = 
        I_∅(e_1) ∪ I_∅(e_2)\),
        therefore 
        \[(x, y) ∈ I_∅(e_1) ⟹ (x, y) ∈ I_∅(e)\]
        Thus we have
        \begin{itemize}[nosep]
            \item either \((x, y) ∈ I_∅(e)\) and \(x = y\)
            \item or \(\exists z, z', \text{ s.t. } (x, z), (z', y) ∈ I(p)\)
        \end{itemize}
        \item If \(e\) is of the form \(e_1 e_2\),
        then 
        \[
            (x, y) ∈ I(e_1 e_2)
            ⟹ ∃ k, \text{ s.t. } (x, k) ∈ I(e_1)  \text{ and }  (k, y) ∈ I(e_2) 
        \]
        Then by induction hypothesis for \(e_1\), we have 
        \begin{itemize}[nosep]
            \item either \((x, k) ∈ I_∅(e_1)\) and \(x = k\)
            \item or \(\exists z, z', \text{ s.t. } (x, z), (z', k) ∈ I(p)\)
        \end{itemize}
        by induction hypothesis for \(e_2\)
        \begin{itemize}[nosep]
            \item either \((k, y) ∈ I_∅(e_2)\) and \(k = y\)
            \item or \(\exists z, z', \text{ s.t. } (k, z), (z', y) ∈ I(p)\)
        \end{itemize}
        
        Then there are 4 different cases:
        \begin{itemize}
            \item If both 
            \begin{itemize}[nosep]
                \item \((x, k) ∈ I_∅(e_1)\) and \(x = k\)
                \item \((k, y) ∈ I_∅(e_2)\) and \(k = y\)
            \end{itemize}
            are true, then \((x, y) ∈ I_∅(e)\) by rule of composition;
            and \(x = y\) by transitivity of equality.
            \item if both 
            \begin{itemize}[nosep]
                \item \((x, k) ∈ I_∅(e_1)\) and \(x = k\)
                \item \(∃ z, z', \text{ s.t. } (k, z), (z', y) ∈ I(p)\)
            \end{itemize}
            are true, because \(x = k\), thus from the second point we have 
            \[\exists z, z', \text{ s.t. } (x, z), (z', y) ∈ I(p)\]
            hence the result is true.
            \item if both 
            \begin{itemize}[nosep]
                \item \(\exists z, z', \text{ s.t. } (x, z), (z', k) \in I(p)\)
                \item \((k, y) ∈ I_∅(e_2)\) and \(k = y\)
            \end{itemize}
            are true, because \(k = y\), thus from the first point we have 
            \[\exists z, z', \text{ s.t. } (x, z), (z', y) \in I(p)\]
            hence the result is true.
            \item if both 
            \begin{itemize}[nosep]
                \item \(∃ z, z', \text{ s.t. } (x, z), (z', k) ∈ I(p)\)
                \item \(∃ z, z', \text{ s.t. } (k, z), (z', y) ∈ I(p)\)
            \end{itemize}
            is true, then there exists \((x, z)\) and \((z', y)\) in \(I(p)\)
            hence the result is valid
        \end{itemize}
        \item If \(e\) is of the form \((e_1)*\) for some \(e_1\).
        Then by definition of the star operator in \(\REL\),
        \((x, y) ∈ (e_1)*\) means there exists \(n ∈ ℕ\),
        s.t. \((x, y) ∈ {(e_1)}^{n}\).
        Then we can prove this result by induction on \(n\), 
        using a strategy similar to the multiplication case.
        \item If \(e\) is of the form \(\overline{e_1}\),
        then by definition \(e_1\) cannot contain primitive action.
        Hence \(e_1\) and \(e\) will not contain \(p\).
        Therefore the interpretation of \(p\) do not matter to the interpretation.
        Thus we have \[(x, y) ∈ I_∅(e)\]
        and by \Cref{the: only one action var}, \(x = y\) \qedhere
    \end{itemize}
\end{proof}

Finally, with all the lemma in place, we can prove that KAT is insufficient in encoding incorrectness logic. 
This result demonstrates crucial limitation about domain and reachability reasoning in KAT.

\begin{theorem}\label{the: KAT not able to express incorrectness logic}
    \(\incorTriple{b}{p}{c}\)
    cannot be expressed in \(\REL\).
\end{theorem}

\begin{proof}
    First, by \Cref{the: redundancy of alphabet},
    we only need to show that there does not exist
    \[e₁, {e₂} ∈ \KAT_{\{p\},\{b, c\}}\]
    that can express incorrectness logic.

    Let's assume that there exist \({e₁}\) and \({e₂}\) 
    in \(\KAT_{\{p\},\{b, c\}}\)
    such that
    \[I(e₁) = I(e₂) ⟺ \incorTriple{I(b)}{I(p)}{I(c)}\]  holds for all relational interpretation \(I\).

    Consider the relational KAT \(ℛ\) 
    that contains all the relations and predicates over \(\{0, 1\}\).
    We will construct a pair of interpretation on \(b, c, p\) 
    to show a contradiction: 
    \begin{align*}
        I_{\emptyset}(p) & ≜ ∅ 
        & I(p) & ≜ \{(0, 1)\} \\
        I_{\emptyset}(b) & ≜ \{(0, 0)\}
        & I(b) & ≜ \{(0, 0)\} \\
        I_{\emptyset}(c) & ≜ \{(1, 1)\}
        & I(c) & ≜ \{(1, 1)\}.
    \end{align*}
    Where the incorrectness triple
    \(\incorTriple{b}{p}{c}\) is valid with interpretation
    \(I\), but not with \(I_{∅}\).  And the only difference between
    \(I\) and \(I_{∅}\) is that \(p\) is mapped to \(∅\)
    in \(I_{∅}\).

    Since \(I_{∅}\) valuates the only action variable \(p\) as \(∅\),
    By \Cref{the: only one action var} 
    all the elements of \(I_∅(e₁)\) must be of the form \((x, x)\).
    Then because the incorrectness triple \(\incorTriple{b}{p}{c}\)
    is invalid with \(I_{∅}\),
    \[I_∅(e₁) ≠ I_∅(e₂).\]
    Without loss of generality, assume that
    \((x, x) ∈ I_∅(e₁)\), but not in
    \(I_∅(e₂)\).  Then by monotonicity of KAT operators,
    \((x, x) ∈ I(e₁)\).  We will derive a contradiction
    from the fact that \((x, x) ∈ I(e₂)\) but
    \((x, x) ∈ I_∅(e₂)\).  We can summarize the
    above strategy using \Cref{fig: proof of KAT cannot encode IL}.

    Because \((x, x) ∉ I_∅(e₂)\)
    and the only element of the action \(I(p)\) is \((1, 0)\),
    none of the conditions in \Cref{the: KAT inccorrectness logic core lemma} is satisfied,
    therefore \((x, x)\) cannot be in \(I(e₂)\),
    which contradicts the earlier result stating \((x, x) ∈ I(e₂)\).
\end{proof}

\begin{figure}
    \centering
    \begin{tikzcd}[row sep=1.5em, column sep=1.5em]
        (x, x) \in I(e₁)
            \arrow[rrr, "I(e₁) = I(e₂)"] 
            &&& 
        (x, x) \in I(e₂) \\
        & I(e₁) 
            \arrow[r, equal]
        & I(e₂) & \\
        & I_∅(e₁) 
            \arrow[u, hook, "\text{monotonicity}"]
            \arrow[r, equal, "/" marking]
        & I_∅(e₂) 
            \arrow[u, hook, "\text{monotonicity}"']
        & \\
        (x, x) ∈ I_∅(e₁) 
            \arrow[uuu, "\text{by monotonicity}"] &&& 
        (x, x) ∉ I_∅(e₂) 
            \arrow[uuu, dash, "\text{contradiction}"', "×"marking]\\
    \end{tikzcd}
    \caption{Relation of interpretations \(I\) and \(I_{∅}\)}\label{fig: proof of KAT cannot encode IL}
\end{figure}

One strategy for exploiting the symmetry between Hoare and incorrectness logic
is to extend KAT with a codomain operator.  Similar ideas have been explored in prior work~\cite{Möller_O’Hearn_Hoare_2021}. However,
rather than adopting a full-fledged codomain operator, it suffices for our
purposes to consider a equational theory that only extends KAT with a top
element.  Similar algebraic structure has also been considered in prior
work~\cite[Section~4]{Mamouras_2017}, though for a different purpose.

\begin{definition}[Kleene Algebra with Top and Tests]
  A Kleene Algebra with Top and Tests, or TopKAT, is a KAT \(𝒦\) that contains a largest
  element \(⊤\); that is, for all elements \(p ∈ 𝒦\),
  \[⊤ ≥ p.\]
  A relational TopKAT over \(X\) is a relational KAT that includes the complete relation \(X × X\).
\end{definition}

\begin{theorem}[TopKAT can Express Codomain]\label{the: TopKAT encodes domain PRIMITIVE}
    For all relational TopKATs \(ℛ\),
    and \(p, q ∈ ℛ\) The following is true:
    \[⊤ p = ⊤ q ⟺ \cod(p) = \cod(q)
    \text{ and }
    ⊤ p ≤ ⊤ q ⟺ \cod(p) ⊆ \cod(q).\]
\end{theorem}

\begin{proof}
  For all relations \(r \subseteq X \times X\):
    \begin{align*}
        \top ⋅ r 
        & = \{(z, y) \mid z \in X \land \exists x, (x, y) \in r\} 
        = \{(z, y) \mid z \in X \land y \in \cod(r)\} 
    \end{align*}
    Therefore for two relation \(p, q\), we will have 
    \begin{align*}
        ⊤ ⋅ q = ⊤ ⋅ p & ⟺ 
        \{(z, y) ∣ z ∈ X ∧ y ∈ \cod(q)\}
        = \{(z, y) ∣ z ∈ X ∧ y ∈ \cod(p)\} \\
        & ⟺ \cod(q) = \cod(p) \\
        ⊤ ⋅ q ≤ ⊤ ⋅ p & ⟺ 
        \{(z, y) ∣ z ∈ X ∧ y ∈ \cod(q)\}
        \subseteq \{(z, y) \mid z \in X \land y \in \cod(p)\} \\
        & \iff \cod(q) \subseteq \cod(p) \qedhere
    \end{align*} 
\end{proof}

We also provide a shorthand for domain reasoning. 
For two terms \(e_1, e_2  ∈  \KAT\), we write
\[\REL  ⊧  \dom(e_1)  ≥  \dom(e_2),\] when 
\(\dom(I(e_1))  ⊇  \dom(I(e_1))\) for all relational KAT interpretations \(I\);  
and similarly for relational TopKAT and general relational TopKAT.  
Then \Cref{the: TopKAT encodes domain PRIMITIVE} implies the following:
\begin{lemma}\label{the: top element represent domain}
    For two KAT terms \(e_1, e_2  ∈  \KAT_{K, B}\):
    \begin{align*}
        \TopREL  ⊧  e_1  ⊤   ≥  e_2  ⊤  &  ⟺ \REL  ⊧  \dom(e_1)  ≥  \dom(e_2) \\
        \TopREL  ⊧   ⊤  e_1  ≥   ⊤  e_2 &  ⟺  \REL  ⊧  \cod(e_1)  ≥  \cod(e_2)
    \end{align*}
\end{lemma}

\begin{corollary}\label{the: topkat can express incorrectness logic normal termination}
    For all relational TopKATs \((ℛ, ℬ)\),
    and \(p ∈ ℛ\), \(b, c \in ℬ\)
    we have the following:
    \[{⊤ bp ≥ ⊤ c} ⟺ {\incorTriple{b}{p}{c}}\]
\end{corollary}

Notice that the left hand side of this equivalence makes sense in all TopKATs,
not just relational ones.
Thus it is natural to generalize the definition of incorrectness triple to all TopKATs
using the inequality \(\top bp \geq \top c\).
As a matter of fact, just by using the equational theory of TopKAT,
we can find several equivalent formulations of incorrectness triple:

\begin{theorem}[Equivalent Formulation of Incorrectness Logic]
  Given a TopKAT \((𝒦, ℬ)\), where \(p ∈ 𝒦\) and
  \(b, c ∈ ℬ\), we say that an incorrectness triple
  \(\incorTriple{b}{p}{c}\) is valid if the following equivalent conditions are
  met:
  \[⊤ b p ≥ ⊤ c ⟺ ⊤ b p ≥ c ⟺ ⊤ b p c = ⊤ c\]
\end{theorem}

\begin{proof}
We show that these conditions are equivalent in all TopKATs.
\begin{itemize}
    \item First show \[⊤ b p ≥ ⊤ c ⟺ ⊤ b p ≥ c,\]
    the \(⟹\) is true because \(⊤ ≥ 1\):
    \[\top b p \geq \top c \geq c,\]
    the \(\impliedby\) can be proven by idempotency of \(\top\):
    \[\top b p = \top \top b p \geq \top c.\]
    \item Then show \[\top b p \geq \top c \iff \top b p c = \top c,\]
    the \(\impliedby\) can be shown by \(1 \geq c\):
    \[\top b p \geq \top b p c = \top c,\]
    the \(\implies\) is by two inequalities:
    \begin{align*}
        \top b p \leq \top & \implies \top b p c \leq \top c \\
        c \leq 1 \land \top b p \geq \top b p c & \implies \top b p \geq \top b p c = \top c.\\
    \end{align*}
    Therefore we have our conclusion \(\top b p c = \top c\). \qedhere
\end{itemize}
\end{proof}

A similar encoding involving \(\top\) was also mentioned by \citet{OHearn_2020}.
We want to show that this abstraction is enough to capture all the rules of
incorrectness logic.  Indeed most of the the rules are formulated using program
operations expressible in \(\KAT\) ~\cite{OHearn_2020}.  We
focus here on the proof rules concerning normal program termination, and we will
further investigate the rules with error in \Cref{sec: failkat and error}.


\begin{figure}
    \begin{mathpar}
        \inferrule[Empty]
        {\\}{\incorTriple{b}{p}{0}}
    
        \and
        \inferrule[Consequence]
        {b \leq b' \\ \incorTriple{b}{p}{c} \\ c' \leq c}
        {\incorTriple{b'}{p}{c'}}
    
        \and 
        \inferrule[Disjunction]
        {\incorTriple{b_1}{p}{c_1} \\ \incorTriple{b_2}{p}{c_2}}
        {\incorTriple{b_1 + b_2}{p}{c_1 + c_2}}
    
        \and 
        \inferrule[Identity]
        {\\} {\incorTriple{b}{1}{b}}
    
        \and 
        \inferrule[Composition]
        {\incorTriple{a}{p}{b} \\ \incorTriple{b}{q}{c}}
        {\incorTriple{a}{pq}{c}}
    
        \and 
        \inferrule[Choice-Left]
        {\incorTriple{a}{p}{b} }
        {\incorTriple{a}{p + q}{b}}
    
        \and 
        \inferrule[Choice-Right]
        {\incorTriple{a}{q}{b} }
        {\incorTriple{a}{p + q}{b}}
    
        \and 
        \inferrule[Assume]
        {\\}
        {\incorTriple{b}{c}{bc}}
    
        \and 
        \inferrule[Iter-Zero]
        {\\}{\incorTriple{b}{p^*}{b}}
    
        \and 
        \inferrule[Iter-NonZero]
        {\incorTriple{b}{p^* p}{c}}{\incorTriple{b}{{p}^*}{c}}
    
        \and
        \inferrule[Iter-Dependent]
        {\forall n \in ℕ, \incorTriple{b_n}{p}{b_{n + 1}}}
        {\incorTriple{b_0}{{p}^*}{\sup_{n \in ℕ} b_{n}}}
    \end{mathpar}
    \caption{Incorrectness logic with normal termination}\label{fig: normal terminating Inc rule}
\end{figure}

In \Cref{fig: normal terminating Inc rule}, we present all the rules of
incorrectness logic with normal termination using the syntax of KAT.  (Note
that this differs slightly from \citeauthor{OHearn_2020}'s
original notation; for instance, the sequencing operator \(p;q\) corresponds to
multiplication \(pq\) in KAT, and the logical implication \(b → b'\)
corresponds to order \(b \leq b'\).)  For the Iter-dependent rule (Backwards
Variant in~\cite{OHearn_2020}), the function \(b(n)\) corresponds
to a sequence of tests \((b_n)_{n \in ℕ}\), and the existential
\(∃ n, b(n)\) corresponds to the infinite disjunction of all these
\(b_n\), which we express as \(\sup_{n ∈ ℕ} b_n\).  (Note that \(\sup\)
does not exist in KATs, TopKATs, or boolean algebras in general, and this rule
implicitly assumes that \(\sup_{n \in ℕ} b(n)\) exists.)

\begin{theorem}[Soundness of \(\okState\) State Rules]\label{the: incor logic rule sound ok}
    All the rules of \Cref{fig: normal terminating Inc rule}
    are derivable in all TopKATs.
\end{theorem}

\begin{proof}
    The proofs of each individual rules as follows:
    \begin{itemize}
        \item \textbf{Empty Rule:}
            because 0 is the smallest element 
        \item \textbf{Consequence Rule:}
            because multiplication preserves order
            and \(b' \geq b\), therefore \(\top b' p \geq \top b p\).
            Therefore 
            \[\top b' p \geq \top b p \geq c \geq c'\] 
        \item \textbf{Disjunction Rule:}
            because addition preserves order, therefore 
            \[\top b_1 p + \top b_2 p \geq c_1 + c_2\]
            and by distributivity, we have 
            \[\top (b_1 + b_2) p \geq c_1 + c_2\]
        \item \textbf{Identity Rule:}
            because \(\top \geq 1\),
            therefore \[\top b 1 \geq 1 b 1 \geq b\]
        \item \textbf{Composition Rule:}
            first, by idempotency of \(\top\)
            and associativity of multiplication, we have 
            \[\top a (p q) = \top \top a p q\]
            By order preserving of multiplication, 
            and \(\top a p \geq b\),
            we have \[\top a (p q) = \top \top a p q \geq \top b q \geq c\]
        \item \textbf{Choice Left and Choice Right Rule:}
            by distributivity, we have 
            \[\top b (p + q) 
            = \top b p + \top b q 
            \geq \top b p \geq c\]
            and 
            \[\top b (p + q) 
            = \top b p + \top b q 
            \geq \top b q \geq c\]
        \item \textbf{Assume Rule:}
            since \(\top \geq 1\), 
            we have \[\top b c = \top b c \geq 1 b c = bc\]
        \item \textbf{Iter-Zero Rule:}
            since \({p}^* = p {p}^* + 1\),
            we have 
            \[\top b {p}^* 
            = \top b (p {p}^* + 1)
            \geq \top b 1 \geq b\]
        \item \textbf{Iter-NonZero Rule:}
            since \({p}^* = p {p}^* + 1\),
            we have 
            \[\top b {p}^* 
            = \top b (p {p}^* + 1)
            \geq \top b p {p}^* \geq c\]
        \item \textbf{Iter-Dependent Rule:}
            by definition of \(\sup\),
            in order to show \(\top b_{0} {p}^* \geq \sup_{n \in ℕ} b_{n}\)
            all we need to show is that for all \(m \in ℕ\)
            \(\top b_{0} {p}^* \geq b_{m}\).
            We prove this by induction on \(m\).
            \begin{itemize}
                \item \textbf{Base Case:}
                    we need to show \(\top b_{0} {p}^* \geq b_{0}\).
                    Because \({p}^* = 1 + p{p}^*\),
                    therefore 
                    \[\top b_{0} {p}^* 
                    = \top b_{0} (1 + p{p}^*)
                    \geq \top b_{0} 1 \geq 1 b_{0} 1 = b_{0}\]
                \item \textbf{Inductive Case:}
                    if \(\top b_{0} {p}^* \geq b_{n}\),
                    we need to show \(\top b_{0} {p}^* \geq b_{n+1}\).
                    By premise we have \(\top b_{n} p \geq b_{n + 1}\)
                    Therefore by idempotency of the top element,
                    we have 
                    \begin{align*}
                        \top b_{0} {p}^* 
                        & = \top \top b_{0} (1 + {p}^* p) \\
                        & \geq \top \top b_{0} {p}^* p
                        & 1 + {p}^* p \geq {p}^* \\
                        & \geq \top b_{n} p
                        & \text{by induction hypothesis} \\
                        & \geq b_{n+1}
                        & \text{by premise}
                    \end{align*}
            \end{itemize}   
    \end{itemize}
\end{proof}

\paragraph*{An alternative encoding for Hoare logic}

Since \(\TopKAT\) can express codomain (\Cref{the: top element represent domain}), we can exploit the symmetry between incorrectness logic and Hoare logic (\Cref{sec:incorrectness-and-hoare}) to give another encoding of Hoare logic in \(\TopKAT\): 
\[\top b p \leq \top c.\] 
This is equivalent to the original encoding $bp = bpc$ proposed for KATs~\cite{Kozen_2000} in \emph{all TopKAT}, not just relational ones.  
Since the proof rules of propositional Hoare logic are sound for that encoding~\cite[Theorem~3.1]{Kozen_2000}, they are also sound for ours.

\begin{theorem}[Equivalence of Hoare Logic Formulations]\label{the: hoare logic formulation equivalent}
  For all TopKATs \((𝒦, ℬ)\), and three elements
  \(p \in 𝒦\) and \(b, c \in ℬ\), the following inequalities
  are equivalent:
    \[b p \leq \top c  \iff  \top b p \leq \top c \iff b p = b p c.\]
\end{theorem}

\begin{proof}
\begin{itemize}
    \item We first show the equivalence:
        \[b p ≤ ⊤ c  ⟺  ⊤ b p ≤ ⊤ c.\]
        \(⟸\) is by \(1 ≤ ⊤\),
        thus \[b p \leq \top b p \leq \top c,\]
        and \(⟹\) is by the idempotency of \(\top\),
        multiply both side with \(\top\), we have 
        \[\top b p \leq \top \top c = \top c.\]
    \item Then we show the equivalence
        \[b p \leq \top c  \iff  b p = b p c.\]
        Start with \(⟸\), because \(⊤ ≥ b p\), we have
        \[b p = b p c ≤ ⊤ c.\]
        Then \(⟹\), we start from \(b p ≤ ⊤ c\),
        we first multiply \(\overline{c}\) on both side,
        \[b p \overline{c} \leq \top c \overline{c} = \top 0 = 0,\]
        and because \(b p \overline{c} \geq 0\) (\(0\) is the smallest element),
        we have \[b p \overline{c} = 0.\]
        Finally, add \(b p c\) to both side, we have
        \[b p = b p (\overline{c} + c) = 0 + b p c = b p c.\qedhere\]
\end{itemize}
\end{proof}

\section{(In)completeness and Decidability of TopKAT}\label{sec: properties of TopKAT}


In the previous section, we have shown that the theory of TopKAT subsumes incorrectness logic. In this section, we study some of the properties of its algebraic equational theory.
%
First, we will show that TopKAT is \emph{incomplete} with respect to relational
TopKATs: there are identities that are valid for every relational TopKAT that
cannot be proven using the TopKAT identities alone. This contrasts with what
happens for KAT, which is complete for relational KATs.
%
We will then show the completeness of TopKATs with respect to a class of
\emph{language-based} TopKATs and also with respect to a more general class of
\emph{relational} TopKATs, as well as the decidability of TopKAT equalities.
Finally we will introduce the concept of equational expressiveness,
and show that the general relational TopKAT has the same expressiveness as relational KAT,
hence cannot express incorrectness logic.

\subsection{Incompleteness with Respect to Relational TopKATs}

We start with our negative result, which is the incompleteness over relational TopKATs.

\begin{theorem}\label{the: topkatstar incomplete over relational model}
  \(\TopKAT\) is incomplete over \(\TopREL\): the formulas
  \[(⊤ p) (⊤ p) = ⊤ p \text{ and } p ⊤ p ≥ p\] 
  are valid in every relational TopKAT, but not in every TopKAT\@.
\end{theorem}

\begin{proof}
  We can show that the \((⊤ p) (⊤ p) = ⊤ p\) 
  holds in every relational TopKAT simply by
  unfolding the definitions.  To exhibit a TopKAT where it does not hold,
  consider the following counterexample.  We take a relational KAT over
  \(\{0,1\}\) whose largest element is
  \begin{align*}
    ⊤ & ≜ \{(0,0), (1,1), (0,1)\}.
  \end{align*}
  (Note that this KAT is \emph{not} a relational TopKAT\@: the largest
  element is not the complete relation.)
  Then, by taking a interpretation lifted by \(I(p) ≜\{(0, 1)\}\), we see that
  \begin{align*}
    I(⊤ p) & = \{(0, 1)\} \\
    I((⊤ p) (⊤ p)) & 
        = \{(0, 1)\} ⋅ \{(0, 1)\} 
        = ∅ ≠ I(⊤ p)
  \end{align*}

  And the same counter example also works for 
  \(p ⊤ p ≥ p\).
\end{proof}

In fact, \citeauthor{Pous_Wagemaker_2022}~\cite{Pous_Wagemaker_2023,Pous_Wagemaker_2022} has shown that with the additional axiom \(p ⊤ p ≥ p\), the theory of TopKAT is indeed complete with relational model.

Without this additional axiom, the incompleteness result might be discouraging, since we might not be able to derive some valid theorems of incorrectness logic using TopKAT. However in \Cref{the: incor logic rule sound ok} and \Cref{the: incorrectness logic fail rule sound}, we show that all the rules of incorrectness logic are derivable using either the equational theory of TopKAT or FailTopKAT\@.  Thus,
our framework is at least as strong as the structural proof rules presented by~\citet{OHearn_2020}.

In fact, this power of TopKAT is not accidental: as we will show in~\cref{sec: domain completeness of TopKAT}, TopKAT without the additional axiom \(p ⊤ p ≥ p\), is still complete with respect to domain comparison inequalities. Concretely, given any KAT terms \(e₁, e₂ ∈ \KAT\), the inequalities of the following form:
\[⊤ e₁ ≥ ⊤ e₂ \text{ and } e₁ ⊤ ≥ e₂ ⊤\]
are called domain comparison inequalities; because they corresponds to domain comparisons in relational models (\cref{the: top element represent domain}).
And these forms of inequalities subsumes the encoding of both propositional Hoare and incorrectness logic.

\subsection{Reduction on free models}\label{sec: reduction on free models}

Our goal for \Cref{sec: reduction on free models,sec: complete model for free} is to construct a complete interpretation for TopKAT, by reducing its theory to that of plain KAT.  
In other words, any equation between two TopKAT expressions is logically equivalent to another equation between a pair of corresponding KAT terms.  
We present a streamlined proof that hinges on the universal properties of free KATs and TopKATs, without relying explicitly on language models, unlike previous definitions of reduction~\cite{Pous_Rot_Wagemaker_2021,Kozen_Smith_1997}.  
Similar to previous works, we obtain the
decidability of the equational theory of TopKAT as a corollary of reduction.
However, because of the new notion of reduction,
our decidability result no longer depends on the completeness of the language TopKAT.  
Moreover, our technique helps us to construct complete models and interpretations 
simply by computation, as well as simplifying proofs of other results about TopKAT.


We first note that any free KAT over an alphabet \(K, B\) is also a TopKAT,
where the largest element is \((∑ K)^*\). This fact can be seen by
straightforward induction.

\begin{lemma}\label{the: every free KAT is a TopKAT}
    Every free KAT over alphabet \(K, B\) forms a TopKAT.
\end{lemma}

\begin{proof}
    Since \(\KAT_{K, B}\) is a KAT, we only need to show 
    the expression \((∑ K)^*\) is the largest element of \(\KAT_{K, B}\),
    i.e. \[(∑ K)^* ≥ e, ∀ e ∈ \KAT_{K, B}.\] 
    The above fact can be shown by induction on \(e\);
    some algebraic manipulations below use facts in~\Cref{the: well known fact about KA}:
    \begin{itemize}
        \item \((∑ K)^* ≥ 1\) (by unfolding rule),
              thus \((∑ K)^*\) is larger than \(0, 1\) and every Boolean term.
        \item \((∑ K)^*\) is larger than \(∑ K\),
              which is larger than every primitive action.
        \item Given two expressions \(e₁\) and \(e₂\),
              assume \((∑ K)^*\) is larger than both.
              Because \((∑ K)^* = (∑ K)^* + (∑ K)^*\)
              and addition preserves order,
              \[(∑ K)^* = (∑ K)^* + (∑ K)^* ≥ e₁ + e₂\] 
        \item Given two expressions \(e₁\) and \(e₂\),
              assume \((∑ K)^*\) is larger than both.
              Because \((∑ K)^* = (∑ K)^* ⋅ (∑ K)^*\)
              and multiplication preserves order, 
              \[(∑ K)^* = (∑ K)^* ⋅ (∑ K)^* ≥ e₁ ⋅ e₂.\]
        \item Given a expression \(e\),
              if \((∑ K)^* ≥ t\), then \((∑ K)^* ≥ t^*\).
              Since \((∑ K)^* = ((∑ K)^*)^*\) and star preserves order:
              \[(∑ K)^* = ((∑ K)^*)^* ≥ t^*. \qedhere\]
    \end{itemize}
\end{proof}

Since every free KAT is a TopKAT, every KAT interpretation
\(I : \KAT → \mathcal{K}\) induces a sub-KAT $\Img(I) ⊆ 𝒦$,
and this sub-KAT happens to be a \emph{TopKAT}. Specifically, the image of $(∑ K)^*$
in $𝒦$ is the largest element of $\Img(I)$, and the restricted
$I : \KAT → \Img(I)$ is a TopKAT homomorphism.

This gives us a powerful tool to construct complete TopKAT interpretations.
Since we already know that the KAT interpretations \(G: \KAT → 𝒢\) and
\(h ∘ G: \KAT → \Img(h)\) are injective TopKAT homomorphisms, we can
construct complete TopKAT interpretations by \emph{composition}, 
if we can construct an injective TopKAT interpretation \(r\) of type
\(\TopKAT_{K, B} → \KAT_{K_⊤, B}\):
\begin{align*}
    \TopKAT_{K, B} \xrightarrow{r} \KAT_{K_⊤, B} \xrightarrow{G} 𝒢_{K_⊤, B},\\
    \TopKAT_{K, B} \xrightarrow{r} \KAT_{K_⊤, B} \xrightarrow{G} 𝒢_{K_⊤, B} \xrightarrow{h} \Img(h).
\end{align*} 

In fact, such an injective homomorphism can be obtained by lifting 
the embedding map \(K + B ↪ \KAT_{K_⊤, B}\):
\begin{align*}
    r   & : K + B → \KAT_{K_⊤, B}             \\
    r(p) & ≜ p.                   
\end{align*}
This homomorphism coincides with the \emph{reduction maps} of the same name in
previous works~\cite{Zhang_de_Amorim_Gaboardi_2022, Pous_Wagemaker_2023}.  More
concretely, we can picture $r$ as simply replacing the symbol \(⊤\) in a TopKAT
term with \((∑ K_⊤)^*\), the largest element in \(\KAT_{K_⊤, B}\).

We will show that \(r\) is injective by constructing a left inverse for it.  
In fact, the left inverse \([-]_⊤\) simply interprets the \(⊤\) primitive in \(\KAT_{K_⊤, B}\)
as the largest element.
\begin{lemma}\label{the: equivalence class is the inverse of reduction}
  The map \([-]_⊤: \KAT_{K_⊤, B} → \TopKAT_{K, B}\), where each expression is
  mapped to its corresponding equivalence class, 
  is defined by lifting the following action on the primitives:
  \begin{align*}
    [p]_⊤ & ≜ p & p ∈ K + B \\  
    [⊤]_⊤ & ≜ ⊤.
  \end{align*}
  The map \([-]_⊤\) is a TopKAT homomorphism.
\end{lemma}

\begin{proof}
  Because this map defined by lifting on the primitives,
  it is automatically a KAT homomorphism.
  All we need to show is that \([-]_⊤\) preserves the top element, that is
  \([(∑ K_⊤)^*]_⊤ = (∑ K_⊤)^*\) is the largest element in \(\TopKAT_{K, B}\).

  By construction of \(\TopKAT_{K, B}\), \(⊤\) is the largest element in \(\TopKAT_{K, B}\). 
  Thus, to prove that \((∑ K_⊤)^*\) is also the largest element in \(\TopKAT_{K, B}\),
  it suffices to prove \((∑ K_⊤)^* ≥ ⊤\): \[(∑ K_⊤)^* ≥ ∑ K_⊤ = ⊤ + ∑ K ≥ ⊤. \qedhere\]
\end{proof}

\begin{theorem}[Reduction]
    \([-]_⊤\) is the right inverse of \(r\): \([-]_⊤ ∘ r  = id_{\TopKAT_{K, B}}\).
    More explicitly for all \(e ∈ \TopKAT_{K, B}\): \[\TopKAT_{K, B} ⊧ [r(e)]_⊤ = e.\]
\end{theorem}

\begin{proof}
    Since \([-]_⊤ ∘ r : \TopKAT_{K, B} → \TopKAT_{K, B}\) is a TopKAT interpretation,
    the action on the primitives uniquely determines the interpretation:
    because both \(r\) and \([-]_⊤\) are identity on the primitives,
    therefore \([-]_⊤ ∘ r\) is the identity interpretation on \(\TopKAT_{K, B}\).
\end{proof}

The above theorem matches one of the soundness condition of reductions in 
previous works~\cite{Zhang_de_Amorim_Gaboardi_2022,Kozen_Smith_1997,Pous_Rot_Wagemaker_2021},
which was typically proven by a monolithic induction on the structure of terms.
Our approach, on the other hand, relies on establishing fine-grained 
algebraic properties, like~\cref{the: every free KAT is a TopKAT,the: equivalence class is the inverse of reduction};
then the theorem follows simply by computing the action of \([-]_⊤ ∘ r\) on primitives.

Since \(r\) has a right inverse, it is indeed the injective interpretation we desired, 
and it is also a complete interpretation:
\[\TopKAT_{K, B} ⊧ e₁ = e₂ ⟺ r(e₁) = r(e₂),\]
With the completeness of \(r\), we can already show the complexity of TopKAT.
The complexity results echos previous proofs~\cite{Zhang_de_Amorim_Gaboardi_2022,Pous_Wagemaker_2023},
but we are able to obtain this result without completeness of TopKAT language interpretation,
which is essential in previous proofs. 

\begin{corollary}[Complexity]\label{the: PSPACE-completeness of TopKAT}
  Given two expressions \(e₁, e₂ ∈ \TopKAT_{K, B}\), deciding whether these two terms
  are equal is PSPACE-complete.
\end{corollary}

\begin{proof}
    Deciding KAT equality is a sub-problem of deciding TopKAT equality,
    and KAT equality is PSPACE-hard \cite{Cohen_Kozen_Smith_1999};
    therefore TopKAT equality is PSPACE-hard.

    To decide the equality of \(e₁, e₂\),
    we first remove all the redundant primitives that do not appear in \(e₁, e₂\)
    from the alphabet \(K, B\). Then we compute \(r(e₁)\) and \(r(e₂)\),
    each taking polynomial space (of \(|e₁| + |e₂|\)) to store;
    and we use the standard algorithm \cite{Cohen_Kozen_Smith_1999}
    to decide whether \(r(e₁) = r(e₂)\) in \(\KAT_{K_⊤, B}\),
    this will also take polynomial space.
    Hence, the decision procedure for TopKAT equality in PSPACE.

    Thus deciding TopKAT equality is PSPACE-complete.
\end{proof}


\subsection{Computing the complete interpretations}\label{sec: complete model for free}

Designing complete interpretations and models was not always easy.
In fact, in previous works \cite{Zhang_de_Amorim_Gaboardi_2022_POPL},
the authors made a mistake in the definition of language TopKAT,
which was fixed later \cite{Zhang_de_Amorim_Gaboardi_2022} 
by suggestion of Pous et al. \cite{Pous_Wagemaker_2022}.
However, with the results in~\Cref{sec: reduction on free models},
we can construct the complete interpretation just by composition,
and compute the complete model by computing the range of the complete interpretation.

We already know that there are two complete interpretations of TopKAT defined as follows:
\begin{align*}
    \TopKAT_{K, B} \xrightarrow{r} \KAT_{K_⊤, B} \xrightarrow{G} 𝒢_{K_⊤, B},\\  
    \TopKAT_{K, B} \xrightarrow{r} \KAT_{K_⊤, B} \xrightarrow{G} 𝒢_{K_⊤, B} \xrightarrow{h} \Img(h),
\end{align*}
with a complete language model \(𝒢_{K_⊤, B}\), 
and a complete model consisting of relations \(\Img(h)\).

The operations in these models can be recovered by computing these maps.
For example, the multiplication operation in the language TopKAT can be computed as follows:
\[G ∘ r(e₁ ⋅ e₂) = G(r(e₁) ⋅ r(e₂)) = G(r(e₁)) ⋄ G(r(e₂)).\]
Since \(r\) does not change the multiplication operation,
the multiplication in the language TopKAT is the same as in language KAT.
In fact, as \(r\) does not change any operation in KAT,
most operations in language TopKAT are the same as language KAT.
Thus, we only need to compute the top element in language TopKAT.

The top element in language TopKAT can be computed in the same fashion:
\[G ∘ r(⊤) = G((∑ K_⊤)^*) = GS_{K_⊤, B},\]
i.e. the top element is just the complete language.

\begin{corollary}\label{the: language TopKAT for free}
    The language TopKAT inherits all the operations in language KAT,
    except the top element, which is defined as the full language.
    And such models are complete with \(G ∘ r\) as a complete interpretation.
\end{corollary}

In the same way, we know that complete models consisting of relations (a.k.a. general relational TopKAT) 
will have the same operations as relational KATs.
However, in this case the characterization of the computed top: \(h ∘ G ∘ r(⊤)\)
is not as simple as the full language,
but we know it is the largest relation in the range of \(h ∘ G ∘ r\):

\begin{corollary}\label{the: general relational TopKAT for free}
    The general relational TopKAT inherits all the operations in relational KAT,
    except the top element is the largest relation.
    And such models are complete with \(h ∘ G ∘ r\) as a complete interpretation.
\end{corollary}

Finally, to investigate whether we can use general relational TopKAT
to encode incorrectness logic,
we will provide a short proof that general relational TopKATs
are as expressive as relational KATs~\cite{Zhang_de_Amorim_Gaboardi_2022};
that is, every property on relations that can be encoded using general relational TopKAT,
is already encodable in the relational KAT.
Hence, adding a top element does not give extra expressive power in general relational TopKAT.

The original proof~\cite[Lemma 2]{Zhang_de_Amorim_Gaboardi_2022} 
encodes every TopKAT expression using a KAT term,
and then uses two pages to prove the soundness of this encoding.
Here we show the aforementioned encoding is simply the reduction \(r\).

\begin{definition}
    Given two expressions \(e₁, e₂ ∈ \TopKAT\), and n primitives \(p₁, p₂, … , pₙ ∈ K + B\),
    we say that an n-ary predicate \(P\) is \emph{expressible} by 
    equation \(e₁ = e₂\) for a class of TopKATs \(\mathsf{K}\) 
    when for all interpretations \(I\) into TopKATs in \(\mathsf{K}\),
    the following equivalence holds:
    \[I(e₁) = I(e₂) ⟺ P(I(p₁), I(p₂), …, I(pₙ)).\]
\end{definition}

\begin{theorem}[Expressiveness of general relational TopKAT]\label{the: TopGREL expressive power}
    Given an alphabet \(K, B\), an n-ary predicate \(P\) on relations,
    the predicate \(P\) over primitives \(p₁, p₂, … , pₙ ∈ K\) is expressible in
    general relational TopKAT if and only if it is expressible in relational KAT.
\end{theorem}

\begin{proof}
    A predicate expressible in relational KAT is also expressible 
    in general relational TopKAT using the same pair of terms,
    we only need to show the converse.
    Assume a predicate \(P\) is expressible in general relational TopKAT,
    then there exists two TopKAT expressions \(e₁, e₂ ∈ \TopKAT_{K, B}\) s.t. 
    for all general relational TopKAT interpretations \(I_⊤\):
    \[I_⊤(e₁) = I_⊤(e₂) ⟺ P(I_⊤(p₁), I_⊤(p₂), … , I_⊤(pₙ));\]

    We take an arbitrary relational KAT interpretation \(I\) from \(\KAT_{K_⊤, B}\).
    Notice \(\Img(I)\), the range of \(I\), 
    is a relational KAT with the largest element \(I((∑ K)^*)\),
    i.e. \(\Img(I)\) is a general relational TopKAT.
    Because \(I\) is a KAT interpretation, 
    it preserves all the KAT operations and the largest element.
    Hence, \(I\) is a TopKAT homomorphism from \(\KAT_{K_⊤, B}\) to \(\Img(I)\).

    Then we can construct \(I ∘ r: \TopKAT_{K, B} → \Img(I)\),
    a general relational interpretation:
    \begin{align*}
        I(r(e₁)) = I(r(e₂))
         & ⟺ I ∘ r(e₁) = I ∘ r(e₂)                           \\
         & ⟺ P(I ∘ r(p₁), … , I ∘ r(pₙ))
            & \text{\(I ∘ r\) is a \(\TopGREL\) interpretation} \\
         & ⟺ P(I(p₁), … , I(pₙ))
            & r(pᵢ) = pᵢ
    \end{align*}
    Thus the two KAT expressions \(r(e₁), r(e₂) ∈ \KAT_{K_⊤, B}\) also can express the predicate \(P\).
\end{proof}

Since the image of \(I\) is not necessarily a relational TopKAT, where the top element is interpreted as the complete relation, the above trick does not work for relational TopKAT.
In fact, in~\Cref{the: topkat can express incorrectness logic normal termination,the: KAT not able to express incorrectness logic}, we have already showed that relational TopKAT is strictly more expressive than relational KAT,
since relational TopKAT can encode incorrectness logic, where relational KAT cannot.


\subsection{(Co)domain Completeness}\label{sec: domain completeness of TopKAT}

As we have shown in~\Cref{the: topkatstar incomplete over relational model}, TopKAT is not complete over relational models, which are crucial for applications in program logics (\Cref{the: top element represent domain}).  
However, \citet{Pous_Wagemaker_2023} later showed that we can obtain a complete theory for relational models by simply adding the axiom \(p ⊤ p ≥ p\) to the theory of TopKAT. 

Here, we take a different approach than Pous et al.~\cite{Pous_Wagemaker_2023}: instead of extending the TopKAT framework, we will restrict the completeness result.
In particular, the encoding of incorrectness logic and Hoare Logic in TopKAT~\cite{Zhang_de_Amorim_Gaboardi_2022}
relies only on the ability of TopKAT to compare the domain and codomain of two
relations.  This raises the question of whether TopKAT suffices for proving such
properties; that is, whether the following completeness results hold: for
\(e₁, e₂ ∈ \KAT_{K, B}\) (i.e. \(⊤\) does not appear in \(e₁\) and \(e₂\))
\begin{align*}
    \REL ⊧ \cod(e₁) ≥ \cod(e₂) & ⟺ \TopKAT ⊧ ⊤ e₁ ≥ ⊤ e₂ & \text{codomain completeness} \\
    \REL ⊧ \dom(e₁) ≥ \dom(e₂) & ⟺ \TopKAT ⊧ e₁ ⊤ ≥ e₂ ⊤ & \text{domain complete}
\end{align*}

In this section, we prove that these equivalences hold, even without the additional axiom.
However, they do \emph{not} hold if we allow expressions that contain top.
For example, let \(e₁ ≜ p ⊤ p\), and \(e₂ ≜ p\). Since \(p ⊤ p ≥ p\) holds in
relational TopKAT, thus \(\dom(p ⊤ p) ≥ \dom(p)\). 
However, \(p ⊤ p ⊤ ≥ p ⊤\) is not provable in TopKAT, 
because the inequality is not valid with the language interpretation.
The incompleteness of codomain comparison can also be shown using the same example.

\subsubsection{Codomain completeness}

The core insight to prove the domain completeness result is 
to construct a specific relational interpretation \(h ∘ i ∘ G\),
where its codomain is equivalent to the complete TopKAT interpretation \(G ∘ r\):
\[\cod(h ∘ i ∘ G(e)) = G ∘ r(e),\]
where \(i\) is the natural inclusion homomorphism \(i: 𝒢_{K, B} ↪ 𝒢_{K_⊤, B}\), 
that maps every language to itself;
and \(h\) is the classical embedding of language KAT into relational KAT~\cite{Kozen_Smith_1997},
which we will recall as follows:
\[h(W) = \{(w, w ⋄ w') ∣ w ∈ GS, w' ∈ W\}.\]
Although \(i\) will not change the outcome of \(G\),
it will add a new primitive action \(⊤\) to the alphabet, hence changing the outcome of \(h\).
Such addition will equate the codomain of \(h ∘ i ∘ G(e)\) 
with the complete TopKAT interpretation \(G ∘ r\) of \(⊤ e\).
The proof of this equality is by simply computing both sides of the equation.

\begin{lemma}\label{the: codomain completeness core lemma}
    For any expression \(e ∈ \KAT_{K, B}\),
    \[\cod(h ∘ i ∘ G(e)) = G ∘ r(e).\]
\end{lemma}

\begin{proof}
    We explicitly write out the domain and codomain of the functions in
    the relational KAT interpretation \(h ∘ i ∘ G\) for the ease of the reader:
    \[\KAT_{K, B}
        \xrightarrow{G} 𝒢_{K, B}
        \xrightarrow{i} 𝒢_{K_⊤, B}
        \xrightarrow{h} 𝒫(𝒢_{K_⊤, B} × 𝒢_{K_⊤, B}).\]
    In this case, \(h\) is a KAT homomorphism from \(𝒢_{K_⊤, B}\):
    \[h(W) = \{(w, w ⋄ w₁) ∣ w ∈ GS_{K_⊤, B}, w₁ ∈ S\}.\]
    Since the reduction \(r\) preserves expressions without \(⊤\),
    let \(e ∈ \KAT_{K, B}\) (i.e. \(e\) does not contain \(⊤\)),
    \[G ∘ r(⊤) = GS_{K_⊤, B} \\ G ∘ r(e) = G(e).\]
    Therefore, for any expression \(e ∈ \KAT_{K, B}\)
    \begin{align*}
        \cod(h ∘ i ∘ G(e))
         & = \{w α w₁ ∣ w α ∈ GS_{K_⊤, B}, α w₁ ∈ G(e)\} \\
         & = GS_{K_⊤, B} ⋄ G(e)                          \\
         & = (G ∘ r(⊤)) ⋄ (G ∘ r(e))                     \\
         & = G ∘ r(e). \qedhere
    \end{align*}
\end{proof}

\Cref{the: codomain completeness core lemma} established a connection between 
the codomain operator and the language interpretation of TopKAT.
Then by completeness of the language interpretation, 
we will obtain the completeness of codomain comparison.

\begin{theorem}[Codomain completeness]\label{the: codomain completeness}
    Given two expressions \(e₁, e₂ ∈ \KAT_{K, B}\) (i.e. expressions without \(⊤\)),
    then codomain comparison is complete:
    \begin{align*}
        \REL ⊧ \cod(e₁) ≥ \cod(e₂) & ⟺ \TopKAT ⊧ ⊤ e₁ ≥ ⊤ e₂.
    \end{align*}
\end{theorem}

\begin{proof}
    Given the natural inclusion homomorphism: \(i: \KAT_{K, B} → \KAT_{K_⊤, B}\),
    we show that the following are equivalent:
    \begin{enumerate}
        \item \(\REL ⊧ \cod(e₁) ≥ \cod(e₂).\)
        \item \(\cod(h ∘ i ∘ G(e₁)) ≥ \cod(h ∘ i ∘ G(e₂)).\)
        \item \(\TopKAT ⊧ ⊤ e₁ ≥ ⊤ e₂.\)
    \end{enumerate}

    We first show that \(1 ⟹ 2\), by definition, \(\REL ⊧ \cod(e₁) ≥ \cod(e₂)\)
    implies \(\cod(I(e₁)) ≥ \cod(I(e₂))\) for all relational KAT interpretations \(I\).
    Because \(h ∘ i ∘ G\) is a relational KAT interpretation, so \(1 ⟹ 2\).

    We show \(2 ⟹ 3\), which uses the equality discussed above, 
    and proved in~\Cref{the: codomain completeness core lemma}:
    \begin{align*}
             & \cod(h ∘ i ∘ G(e₁)) ≥ \cod(h ∘ i ∘ G(e₂))           \\
        ⟺ {} & G ∘ r(⊤ e₁) ≥ G ∘ r(⊤ e₂)
             & \text{\Cref{the: codomain completeness core lemma}} \\
        ⟺ {} & \TopKAT ⊧ ⊤ e₁ ≥ ⊤ e₂.
             & \text{Completeness of \(G ∘ r\)}
    \end{align*}

    Finally, we show \(3 ⟹ 1\), by \Cref{the: top element represent domain}:
    \[\TopKAT ⊧ ⊤ e₁ ≥ ⊤ e₂ ⟹ \TopREL ⊧ ⊤ e₁ ≥ ⊤ e₂ ⟹ \REL ⊧ \cod(e₁) ≥ \cod(e₂). \qedhere\]
\end{proof}

\subsubsection{Domain completeness}

The domain completeness result can be derived from codomain completeness 
by observing properties of opposite TopKAT and the converse operator \((-)^{∨}\), 
both of which we will recall below.

For every TopKAT \(𝒦\), we can construct the opposite TopKAT \(𝒦^{\op}\) 
by reversing the multiplication operation, keeping the sorts and other operations unchanged:
\[p \mathbin{\hat{⋅}} q ≜ q ⋅ p,\]
where \(\hat{⋅}\) is multiplication in \(𝒦^{\op}\) and \(⋅\) is multiplication in \(𝒦\).
By definition, \((-)^{\op}\) is a involution, that is \({(𝒦^{\op})}^{\op} = 𝒦\).
Furthermore, \((-)^{\op}\) is a TopKAT functor,
this means all TopKAT homomorphisms \(h: 𝒦 → 𝒦'\) 
can be lifted to a TopKAT homomorphism on the opposite TopKAT \(h^{\op}: 𝒦^{\op} → {𝒦'}^{\op}\). 
The lifting \(h^{\op}\) is point-wise equal to \(h\):
\[∀ p ∈ 𝒦, h^{\op}(p) ≜ h(p).\]
The fact that \(h^{\op}\) is a TopKAT homomorphism can be proven by unfolding the definition,
and the functor laws are satisfied because \(h^{\op}\) is point-wise equal to \(h\).

There are two important homomorphisms involving opposite TopKAT:
\begin{align*}
    (-)^{∨} & : (X × X)^{\op} → (X × X) &
    \op & : \TopKAT_{K, B} → \TopKAT^{\op}_{K, B} \\  
    (R)^{∨} & = \{(b, a) ∣ (a, b) ∈ R\}, & 
    ∀ p ∈ K + B, \op & (p) = p.
\end{align*}
The \((-)^{∨}\) is the relational converse operator, 
the rules of homomorphism can simply be proven by unfolding of definitions.
The crucial property of \((-)^{∨}\) is that it flips the domain and codomain:
\begin{equation}\label{the: converse flips domain to codomain}
    \dom(R^{∨}) = \cod(R).
\end{equation}
Hence, allowing us to flip the result about codomains and apply it to domains.

\(\op\) is a homomorphism from free TopKAT to its opposite TopKAT;
it can be defined by lifting the embedding function \(K + B ↪ \TopKAT_{K, B}\) on primitives.
Intuitively, given a expression \(e ∈ \TopKAT\), 
\(\op(e)\) will flip all the multiplications in \(e\) recursively.
\begin{lemma}\label{the: injectivity of op}
    the left inverse of \(op\) can be obtained by lifting itself through the \((-)^{\op}\) functor,
    \[\op^{\op}: \TopKAT^{\op} → (\TopKAT^{\op})^{\op} = \TopKAT.\]
    Recall \(\op^{\op}\) is pointwise equal to \(\op\), 
    thus \(\op^{\op} ∘ \op: \TopKAT → \TopKAT\) is the identity interpretation 
    because it preserves all the primitives.
    Thus, \(\op\) has a left inverse, hence it is injective:
    \[e₁ = e₂ ⟺ \op(e₁) = \op(e₂).\]
\end{lemma}

Finally, since the elements in \(\TopKAT^{\op}\) are the same as \(\TopKAT\), 
which are TopKAT expressions modulo provable TopKAT equalities,
theorems about TopKAT expressions are also true for elements in \(\TopKAT^{\op}\).
In particular, codomain completeness (\Cref{the: codomain completeness})
also holds in \(\TopKAT^{\op}\): 
for all expressions \(e₁, e₂ ∈ \TopKAT\),
\begin{equation}\label[equiv]{the: op codomain completeness}
    ⊤ ⋅ \op(e₁) ≥ ⊤ ⋅ \op(e₂) ⟺ \REL ⊧ \cod(\op(e₁)) = \cod(\op(e₂)).
\end{equation}

\begin{theorem}[Domain Completeness]\label{the: domain completeness}
    For all expressions \(e₁, e₂ ∈ \KAT\), the following equivalence hold:
    \[\REL ⊧ \dom(e₁) = \dom(e₂) ⟺ \TopKAT ⊧ e₁ ⊤ ≥ e₂ ⊤.\]
\end{theorem}

\begin{proof}
    \(⟸\) direction is trivial by \Cref{the: top element represent domain};  
    and \(⟹\) direction can be derived as follows:
    let \(I\) be some relational interpretation,
    then \(I^{\op}(\op(-))^∨\) is also a relational interpretation:
    \[I^{\op}(\op(-))^∨: 
        \TopKAT \xrightarrow{\op} \TopKAT^{\op} \xrightarrow{I^{\op}} 
        (X × X)^{\op} \xrightarrow{(-)^{∨}} (X × X).\]
    Thus, we let \(I\) range over all relational interpretations:
    \begin{align*}
        & \REL ⊧ \dom(e₁) ⊇ \dom(e₂)  \\
        & ⟹ ∀ I, \dom(I(e₁)) ⊇ \dom(I(e₂)) \\
        & ⟹ ∀ I, \dom(I^{\op}(\op(e₁))^∨) ⊇ \dom(I^{\op}(\op(e₂))^∨) 
            &\text{specialize \(I\) as \(I^{\op}(\op(-))^∨\)}\\  
        & ⟹ ∀ I, \cod(I^{\op}(\op(e₁))) ⊇ \cod(I^{\op}(\op(e₁))) 
            &\text{\Cref{the: converse flips domain to codomain}}\\
        & ⟹ ∀ I, \cod(I(\op(e₁))) ⊇ \cod(I(\op(e₁))) 
            &\text{\(I^{\op}\) is pointwise equal to \(I\)}\\
        & ⟹ ⊤ ⋅ \op(e₁) ≥ ⊤ ⋅ \op(e₂) 
            &\text{\Cref{the: op codomain completeness}}\\
        & ⟹ \op(⊤ ⋅ e₁) ≥ \op(⊤ ⋅ e₂) 
            & \text{Definition of \(\op\)}\\
        & ⟹ e₁ ⊤ ≥ e₂ ⊤ & \text{\Cref{the: injectivity of op}}
    \end{align*}
\end{proof}

\begin{remark}
    Alternatively, \Cref{the: domain completeness} can also be proven 
    by constructing the following \(h'\):
    \begin{align*}
        h' & : 𝒢_{K, B} → 𝒫(𝒢_{K, B} × 𝒢_{K, B})\\
        h' & (W₁) ≜ \{(w₁ α w, α w) ∣ w₁ α ∈ W₁, α w ∈ GS_{K, B}\}.
    \end{align*}
    Then the proof would mirror that of \Cref{the: codomain completeness},
    replacing \(h\) with \(h'\) and replacing \(\cod\) with \(\dom\).
    However, the proof of \Cref{the: domain completeness} reveals more properties
    of maps like \((-)^{∨}\) and \(\op\), 
    thus we choose to present the current proof of \Cref{the: domain completeness} 
    instead of the alternative proof.
\end{remark}


\section{Modeling Errors in Incorrectness Logic}\label{sec: failkat and error}

One of the advantages of algebraic methods is the ease of extension.
In this section, we show how extending TopKAT with failure can naturally give rise to incorrectness triples that express abnormal termination.  
The main difference arises from the short-circuiting behavior of sequencing with errors.
This can be seen in the following rule for sequential composition, which states that if an error already occurred in \(p\), \(q\) will not be executed.
\[
\inferrule[Composition-Fail]
{ \incorTriple{b}{p}{\errState: c}}
{ \incorTriple{b}{pq}{\errState: c}}.
\]

To capture this type of control flow, we adapt the ideas from
\citet{Mamouras_2017}, who investigated similar issues
in the setting of KAT\@.
\begin{definition}[FailTopKAT]
  A FailTopKAT is a tuple \((\mathcal{F},\mathcal{K},\mathcal{B},\fail)\), where
  \((𝒦, ℬ)\) is a TopKAT, \(\fail ∈ ℱ\), and
  \(𝒦 ⊊ ℱ\). The set \(ℱ\) has the
  structure of a KAT that extends that of \(\mathcal{K}\), except that the right
  annihilation rule \(p ⋅ 0 = 0\) need not hold.  Instead,
  \[\fail ⋅ p = \fail,\] where \(p\) is any element of \(ℱ\).
  (Crucially, we do \emph{not} assume \(⊤ ≥ \fail\).) We call
  \((𝒦,ℬ)\) the \emph{fail-free subalgebras}, 
  which model programs that do not fail.  
  We will omit some of \(𝒦,ℬ,\fail\),
  if they are not used or can be inferred from the context.

  The class of all FailTopKATs is denoted \(\FailTopKAT\).
\end{definition}
Note that the original definition of \citet{Mamouras_2017} allows for try-catch statements and different types of errors.  
We omit these features for simplicity, since they are not needed in incorrectness logic~\cite{OHearn_2020}. 

There exists a canonical procedure for extending a TopKAT \(\mathcal{K}\) with
failures.  The idea, which we adapt from Construction
F~\cite[Definition~4]{Mamouras_2017} is to consider elements of the
form \((p,p') ∈ 𝒦 × 𝒦\), where \(p\) represents
executions that terminate normally, and \(p'\) represents executions that fail.
\begin{definition}[Construction F for \(\FailTopKAT\)]
  Given a TopKAT \((\mathcal{K}, \mathcal{B})\), we construct a FailTopKAT
  \((\mathcal{F}, \mathcal{K'}, \mathcal{B'})\).  The carrier sets are defined
  as 
  \begin{align*}
    ℱ & ≜ 𝒦 × 𝒦 &
    𝒦' & ≜ 𝒦 × \{0_{𝒦}\} &
    \mathcal{B'} & ≜ ℬ × \{0_{𝒦}\},
  \end{align*}
  where \(0_{\mathcal{K}}\) is the additive identity in \(\mathcal{K}\).  The
  operations of \(\mathcal{F}\) are defined as follows
  \begin{align*}
      0_{\mathcal{F}} & ≜ (0_{𝒦}, 0_{𝒦}) \\
      1_{ℱ} & ≜ (1_{𝒦}, 0_{𝒦}) \\
      ⊤_{ℱ} & ≜ (⊤_{𝒦}, 0_{𝒦}) \\
    (p, p') (q, q') & = (p q, p' + pq') \\
    (p, p') + (q, q') & = (p + q, p' + q') \\
    {(p, p')}^* & = ({p}^*, ({p}^*) p') \\
    \fail & = (0_{\mathcal{K}}, 1_{\mathcal{K}}) \\
    \overline{(b, 0_{\mathcal{K}})} & = (\overline{b}, 0_{\mathcal{K}}).
  \end{align*}
\end{definition}
To develop some intuitions for this construction, suppose that \(𝒦\) is a relational TopKAT over \(X\).  
There exists a canonical embedding of \(ℱ\) in \(𝒫(X × X × \{\okState,\errState\})\) that identifies \((p,p') ∈ \mathcal{F}\) with the relation
\(r = p × \{\okState\} ∪ p' × \{\errState\} ⊆ X × X × \{\okState,\errState\}\).
Intuitively, \((x,y,γ) ∈ r\) means that a program took the input state \(x\) to
the output state \(y\), and the bit \(\gamma ∈ \{\okState,\errState\}\) signals whether an error has
occurred.  By looking at the definition of sequential composition under this
reading, it says that we get an error either by getting an error when running
the first command (\(p'\)), or if we successfully run the first command, but get
an error when running the second (\(pq'\));
and we terminates normally only we sequentially execute \(p\) and then \(q\).

The semantics of~\citet{OHearn_2020} follows the same pattern, except that he considered the cases \(\okState\) and \(\errState\) in
separate relations.  We can merge them back into a tuple, for example the
semantics of \(\comSkip\)
\[(\{(x, x) ∣ x ∈ X\}, \emptyset)\] 
coincides with the multiplicative identity \(1\) of 
applying construction F to a relational TopKAT \(\mathcal{K}\): 
\[(1_{\mathcal{K}}, 0).\]
In the same way, the sequential composition is multiplication,
the choice operator is addition, the star operator is the Kleene star,
and the \(\comError\) command is \(\fail\).
Thus applying F construction on a relational TopKAT will
capture the semantics of programs with abnormal termination:

\begin{definition}[Relational FailTopKAT]\label{def:relational-failtopkat}
  A relational FailTopKAT is a FailTopKAT constructed by applying construction F
  to a relational TopKAT\@. The class of all relational FailTopKATs is denoted
  \(\FailTopREL\).
\end{definition}

To better understand how to encode an incorrectness triple using FailTopKAT, we
propose a definition of incorrectness triple equivalent to the original one
\cite[Definition 1 and 4]{OHearn_2020}:
\begin{definition}\label{def: relational validity of incor triple with fail}
  Given a relational FailTopKAT \((\mathcal{F}, \mathcal{B})\),
  \(p \in \mathcal{F}\), and \(b, c \in \mathcal{B}\), for an error code
  \(\gamma \in \{\okState, \errState\}\) an incorrectness triple
  \(\incorTriple{b}{p}{\gamma: c}\) is valid if
    \[\cod(b p) ⊇ \cod(c ⋅ \hat{\gamma)}\] 
    where
    \[ \hat{\gamma} ≜
      \begin{cases}
        1 & \text{if \(\gamma = \okState\)} \\
        \fail & \text{if \(\gamma = \errState\).}
      \end{cases}\]
    and the function \(\cod(-)\) is extended entry-wise:
    \begin{align*}
        \cod((r, q)) & ≜ (\cod(r), \cod(q)).
    \end{align*}
\end{definition}

Following the development of \Cref{sec: formulating incorrectness logic}, we can
obtain a formulation of incorrectness triple with abnormal termination.

\begin{theorem}[Relational Validity]
  For all relational FailTopKATs \((\mathcal{F}, \mathcal{B})\), and \(p, q \in \mathcal{F}\),
  we have
\begin{align*}
    \top p = \top q & \iff \cod(p) = \cod(q) \\
    \top p \leq \top q & \iff \cod(p) \subseteq \cod(q),
\end{align*}
\end{theorem}

\begin{proof}
  Write \(p = (p_1,p_2)\) and \(q = (q_1,q_2)\).  Then, by definition,
  \(\top p = (\top p_1, \top p_2)\) and \(\top q = (\top q_1, \top q_2)\).  Thus,
  \(\top p \leq \top q\) is equivalent to \(\top p_1 \leq \top q_1\) and
  \(\top p_2 \leq \top q_2\), which allows us to conclude.
\end{proof}

\begin{corollary}\label{the: FailTopKAT can express incorrectness logic}
  For all relational FailTopKATs \(\mathcal{F}\), for all \(p \in \mathcal{F}\)
  and for all tests \(b, c \in \mathcal{B}\), and for all
  \(\gamma \in \{\okState,\errState\}\), the following holds
    \[\incorTriple{b}{p}{\gamma: c} \iff \top b p \geq (c \cdot \hat{\gamma}).\]
  where \(\hat{\gamma}\) is defined in \Cref{def: relational validity of incor triple with fail}.
\end{corollary}

Thus, we can generalize incorrectness logic with errors to an arbitrary
FailTopKAT\@.

\begin{definition}[Abstract Incorrectness Triple With Failure]
  Given a \(FailTopKAT\) \((\mathcal{F}, \mathcal{K}, \mathcal{B})\),
  \(b, c \in \mathcal{B}\), \(p \in \mathcal{F}\) and
  \(\gamma \in \{\okState, \errState\}\), we define
  \[\incorTriple{b}{p}{\gamma: c} ≜ \top b p \geq c \cdot
    \hat{\gamma}, \] where \(\hat{\gamma}\) is defined as in 
    \Cref{def: relational validity of incor triple with fail}.
\end{definition}

\begin{figure}
    \begin{mathpar}
        \inferrule[Empty]
        {\\}{\incorTriple{b}{p}{\gamma: 0}}

        \and
        \inferrule[Consequence]
        {b \leq b' \\ \incorTriple{b}{p}{\gamma: c} \\ c' \leq c}
        {\incorTriple{b'}{p}{\gamma: c'}}

        \and
        \inferrule[Disjunction]
        {\incorTriple{b_1}{p}{\gamma: c_1} \\ \incorTriple{b_2}{p}{\gamma: c_2}}
        {\incorTriple{b_1 + b_2}{p}{\gamma: (c_1 + c_2)}}

        \and
        \inferrule[Identity]
        {\\} {\incorTriple{b}{1}{\okState: b, \errState: 0}}

        \and
        \inferrule[Composition-Fail]
        {\incorTriple{a}{p}{\errState: b}}
        {\incorTriple{a}{p q}{\errState: b}}

        \and
        \inferrule[Composition-Normal]
        {\incorTriple{a}{p}{\okState: b} \\ \incorTriple{b}{p}{\gamma: c}}
        {\incorTriple{a}{pq}{\gamma: c}}

        \and
        \inferrule[Choice-Left]
        {\incorTriple{b}{p}{\gamma: c}}
        {\incorTriple{b}{p + q}{\gamma: c}}

        \and
        \inferrule[Choice-Right]
        {\incorTriple{b}{q}{\gamma: c}}
        {\incorTriple{b}{p + q}{\gamma: c}}

        \and
        \inferrule[Assume]
        {\\}
        {\incorTriple{a}{b}{\okState: ab, \errState: 0}}

        \and
        \inferrule[Error]
        {\\}{\incorTriple{b}{\fail}{\errState: b}}

        \and
        \inferrule[Iter-Zero]
        {\\}{\incorTriple{b}{{p}^*}{\okState: b}}

        \and
        \inferrule[Iter-NonZero]
        {\incorTriple{b}{{p}^*p}{\gamma: c}}
        {\incorTriple{b}{{p}^*}{\gamma: c}}

        \and
        \inferrule[Iter-Dependent]
        {\forall n \in ℕ,~ \incorTriple{b_{n}}{p}{\okState: b_{n+1}}}
        {\incorTriple{b_{0}}{{p}^*}{\okState: \sup_{n \in ℕ}b_n}}
    \end{mathpar}
    \caption{Complete set of incorrectness logic proof rule with both normal and
      abnormal termination}\label{fig: all proof rules of inc logic}
\end{figure}

\begin{theorem}[Soundness of Incorrectness Logic Rules in FailTopKAT]\label{the: incorrectness logic fail rule sound}
  The rules in \Cref{fig: all proof rules of inc logic} are valid for any
  FailTopKAT \((\mathcal{F}, \mathcal{K}, \mathcal{B})\),
  \(a, b, c \in \mathcal{B}\) and \(p, q \in \mathcal{F}\).
\end{theorem}

\begin{proof}
    All of the \(\okState\) cases is proved in~\Cref{the: incor logic rule sound ok},
    therefore we just prove all the \(\errState\) case.

    We list all the failure cases of these rules
    and remove all the rules without failure cases here,
    for convenience of the reader:
    \begin{mathpar}
        \inferrule[Empty]
        {\\}{\incorTriple{b}{p}{\errState: 0}}

        \and
        \inferrule[Consequence]
        {b \leq b' \\ \incorTriple{b}{p}{\errState: c} \\ c' \leq c}
        {\incorTriple{b'}{p}{\errState: c'}}

        \and
        \inferrule[Disjunction]
        {\incorTriple{b_1}{p}{\errState: c_1} \\ \incorTriple{b_2}{p}{\errState: c_2}}
        {\incorTriple{b_1 + b_2}{p}{\errState: (c_1 + c_2)}}

        \and
        \inferrule[Identity]
        {\\} {\incorTriple{b}{1}{\errState: 0}}

        \and
        \inferrule[Composition-Fail]
        {\incorTriple{a}{p}{\errState: b}}
        {\incorTriple{a}{p q}{\errState: b}}

        \and
        \inferrule[Composition-Normal]
        {\incorTriple{a}{p}{\okState: b} \\ \incorTriple{b}{p}{\errState: c}}
        {\incorTriple{a}{p}{\errState: c}}

        \and
        \inferrule[Choice-Left]
        {\incorTriple{b}{p}{\errState: c}}
        {\incorTriple{b}{p + q}{\errState: c}}

        \and
        \inferrule[Choice-Right]
        {\incorTriple{b}{q}{\errState: c}}
        {\incorTriple{b}{p + q}{\errState: c}}

        \and
        \inferrule[Assume]
        {\\}
        {\incorTriple{a}{b}{\errState: 0}}

        \and
        \inferrule[Error]
        {\\}{\incorTriple{b}{\fail}{\errState: b}}

        \and
        \inferrule[Iter-NonZero]
        {\incorTriple{b}{{p}^*p}{\errState: c}}
        {\incorTriple{b}{{p}^*}{\errState: c}}
    \end{mathpar}

    The proof are basically the same as~\Cref{the: incor logic rule sound ok},
    since \(FailTopKAT\) share most of the properties of \(\TopKAT\):
    \begin{itemize}
        \item \textbf{Empty:}
            By left-annihilation and \(0\) is the least element (additive identity):
            \[\top b p \geq 0 = 0 \fail\]
        \item \textbf{Consequence Rule:}
            because multiplication preserves order
            and \(b' \geq b\), therefore \(\top b' p \geq \top b p\);
            and because \(c' \leq c\), then \(c' \fail \leq c \fail\).
            Therefore
            \[\top b' p \geq \top b p \geq c \fail \geq c' \fail\]
        \item \textbf{Disjunction Rule:}
            because addition preserves order, therefore
            \[\top b_1 p + \top b_2 p \geq c_1 \fail + c_2 \fail\]
            and by distributivity, we have
            \[\top (b_1 + b_2) p \geq (c_1 + c_2) \fail\]
        \item \textbf{Identity Rule:}
            By left-annihilation and \(0\) is the least element (additive identity):
            \[\top b 1 \geq 0 = 0 \fail\]
        \item \textbf{Composition-Fail Rule:}
            Given \(\top a p \geq b \fail\),
            then by order preserving and associativity of multiplication,
            we have
            \[\top a p q \geq b \fail q = b \fail\]
        \item \textbf{Composition-Normal Rule:}
            first, by idempotency of \(\top\)
            and associativity of multiplication, we have
            \[\top a (p q) = \top \top a p q\]
            By order preserving of multiplication,
            and the two premises \(\top a p \geq b\), \(\top b p \geq c \fail\),
            we have \[\top a (p q) = \top \top a p q \geq \top b q \geq c \fail\]
        \item \textbf{Choice-Left and Choice-Right Rule:}
            by distributivity, we have
            \[\top b (p + q)
            = \top b p + \top b q
            \geq \top b p \geq c \fail\]
            and
            \[\top b (p + q)
            = \top b p + \top b q
            \geq \top b q \geq c \fail\]
        \item \textbf{Error:}
            because \(\top \geq 1\), by order preserving of multiplication
            \[\top b \fail \geq b \fail\]
        \item \textbf{Iter-NonZero Rule:}
            since \({p}^* = p {p}^* + 1\),
            we have
            \[\top b {p}^*
            = \top b (p {p}^* + 1)
            \geq \top b p {p}^* \geq c \fail\]
    \end{itemize}

    Note from the proof we can see all the rules with failure case \(\errState: 0\),
    like Assume and Identity rule,
    are redundant, since the failure case rule can be derived from the failure case of empty rule.
\end{proof}


\section{Examples: Reasoning Using TopKAT and FailTopKAT}

In this section, we show some concrete examples of algebraic program reasoning.
We take the assignment language of \citet{OHearn_2020},
and regard assignments as primitive actions and assume statements as primitive tests.
The relational semantics of this language forms a relational FailTopKAT,
and it also forms a relational TopKAT if we do not consider the \(\comError\) command and
the \(\errState\) post-condition.

\begin{example}[Incorrect Absolute Value Procedure]\label{exp: incorrect absolute value}
    Here is an incorrect procedure for finding the absolute value of \(x\):
    \[\comITE{x < 0}{\comSkip}{\comAssign{x}{-x}},\]
    To have a correct procedure for computing the absolute value the condition of the if statement should be \(x > 0\).
    We can use TopKAT to show that every negative number is reachable by using 
    the following incorrectness triple: 
    \[\incorTriple{x < 0}{\comITE{x < 0}{\comSkip}{\comAssign{x}{-x}}}{x < 0}\]

This triple can be proven using just the theory of TopKAT. 
First, we can unfold the if statement:
\[\incorTriple{x < 0}{ (x < 0) 1 + \overline{(x < 0)} (\comAssign{x}{-x})}{x < 0}\]
Then convert the triple to TopKAT encoding: 
\[\top(x < 0) ((x < 0) 1 + \overline{(x < 0)} (\comAssign{x}{-x})) \geq (x < 0)\]
Finally, we prove the above inequality:
\begin{align*}
    & \top(x < 0) ((x < 0) 1 + \overline{(x < 0)} (\comAssign{x}{-x}))\\
    & \geq \top (x < 0) (x < 0) 1 
        & (p + q) \geq p\\
    & = \top (x < 0) 
        & \text{idempotency of test} \\
    & \geq (x < 0)  & \top \geq 1
\end{align*}
Thus we have shown that 
\[\incorTriple{x < 0}{ (x < 0) 1 + \overline{(x < 0)} (\comAssign{x}{-x})}{x < 0}\]
is valid, and the non-desirable results in \(x < 0\) can be reached.
As this triple can be shown just using the equational theory of TopKAT, 
this triple can be automatically decided using the algorithm in \Cref{the: PSPACE-completeness of TopKAT}.
\end{example}     

\citeauthor{OHearn_2020} motivated the under-approximate triple 
as a way to reason about incorrect programs. 
However the under-approximation logic can have other use cases.
For example, we can mix under-approximation and over-approximation triples to
prove a certain post condition is the strongest
(as in Hoare logic) without a relational semantics.

\begin{example}[Reasoning With Hoare And Incorrectness Logic]\label{exp: hoare and incorrect together}
    The assertion \(x ≥ 0\) is the strongest post condition of program 
    \(\comWhile{x < 0}{\comAssign{x}{x + 1}}\) with precondition \(\true\).

    We can show this by the following two triples:
\begin{align*}
    & \incorTriple{\true}{\comWhile{x < 0}{\comAssign{x}{x + 1}}}{x \geq 0}; \\
    & \hoareTriple{\true}{\comWhile{x < 0}{\comAssign{x}{x + 1}}}{x \geq 0}.
\end{align*}

Because for all \(p\) in some TopKAT, \({p}^* \geq 1\),
the incorrectness triple can be shown as follows
\[\top 1 {((x < 0) (\comAssign{x}^*{x + 1}))}\overline{(x < 0)}
≥ ⊤ 1 1 \overline{(x < 0)}
≥ (x ≥ 0).\]
And because \(⊤ ≥ 1 {((x < 0) (\comAssign{x}^*{x + 1}))}\),
then the Hoare triple can be shown
\[
    1 {((x < 0) (\comAssign{x}^*{x + 1}))}\overline{(x < 0)}
    ≤ ⊤ \overline{(x < 0)}
    = ⊤ (x ≥ 0)
  \]
  \end{example}


\begin{example}[Theorem Proving In Hoare And Incorrectness Logic]
    For all TopKATs \((\mathcal{K}, \mathcal{B})\), and \(b, c \in \mathcal{B}\), \(p \in \mathcal{K}\),
    if \(c \geq \overline{b}\), then following incorrectness and Hoare triples are valid
    \[\incorTriple{c}{\comWhile{b}{p}}{\overline{b}} 
    \text{ and }
    \hoareTriple{c}{\comWhile{b}{p}}{\overline{b}}\]

  This example is a generalization of \Cref{exp: hoare and incorrect together}.
If we have a while loop with condition \(b\),
and the precondition \(c\) is larger than \(\overline{b}\),
then \(\overline{b}\) is the strongest post-condition (in the sense of Hoare logic).

We first show a proof in a relational setting, as a comparison to the algebraic proof.
\begin{itemize}
    \item \(\cod(c {(b p))^* \overline{b}} \supseteq \cod(\overline{b})\):
        because on the left hand side, every output needs to go through the final check 
        of \(\overline{b}\), it will also be in \(\cod(\overline{b})\);
    \item \(\cod(c {(b p)}^* \overline{b}) ⊆ \cod(\overline{b})\):
        if the input of the left hand side is in \(\cod(\overline{b})\), 
        it will not be filtered out by \(c\), will not go into loop \({(b p)}^*\),
        will not be filtered out by \(\overline{b}\), and will be outputted unchanged. 
        thus everything in \(\cod(\overline{b})\) will 
        be a output of \( {(b p)}^* \overline{b}\),
        hence in \(\cod(c {(b p)}^* \overline{b})\).
\end{itemize}

Alternatively, we prove this example algebraically.
Because \({(bp)}^* \geq 1\) and \(c \geq \overline{b}\): 
\[\top c {(b p)}^* \overline{b} \geq \top c 1 \overline{b} = \top \overline{b} \geq \overline{b},\]
and because \(\top \geq \top c {(b p)}^*\):
\[\overline{b} \leq \top \overline{b} \geq \top c {(b p)}^* \overline{b}.\]
We can also show that the Hoare triple is also valid with Kozen's encoding:
\[c {(bp)}^* \overline{b} (\overline{\overline{b}}) = c {(bp)}^* \overline{b} b = c {(bp)}^* 0 = 0.\]
The fact that we can also use Kozen's encoding to reach the same conclusion is not surprising,
as we have shown that Kozen's encoding is equivalent to our encoding in all TopKAT.
 \end{example}

\begin{example}[Error In Loop]
    This example simulates a while loop where the body will encounter an error when \(x \leq 0\),
    and it will do some useful computation \(p\) if it does not encounter the error:
    \[
        \incorTriple{\true}
        {\comWhile{x \geq 0}{\comITE{x \leq 0}{\comError}{p}}}
        {\errState: x = 0}
    \]
    the incorrect loop condition will trigger the possible error in the loop body,
    which is undesirable.


To show this triple, we need to show the following FailTopKAT inequalities:
\[
    \top 1 {((x \geq 0) ((x \leq 0) (\fail) + (\overline{x \leq 0}^*) (p)))} (\overline{x \geq 0}) \geq 
    (x = 0) \fail
\]
The proof is as follow: 
\begin{align*}
    & \top 1 {((x \geq 0) ((x \leq 0) (\fail) + (\overline{x \leq 0}^*) (p)))} (\overline{x \geq 0})\\
    & \geq \top 1 {((x \geq 0) (x \leq 0) (\fail))}^* (\overline{x \geq 0})
        & q + r \geq q\\
    & = \top 1 (x \geq 0) (x \leq 0) (\fail) (\overline{x \geq 0})
        & {q}^* \geq q \\
    & = \top 1 (x \geq 0) (x \leq 0) (\fail) 
        & \fail p = \fail \\
    & = \top (x = 0) \fail 
        & (x \geq 0 \land x \leq 0) = (x = 0)\\
    & \geq (x = 0) \fail & \top \geq 1
\end{align*}

Notice that in the second last step we used the fact 
\[(x \geq 0 \land x \leq 0) = (x = 0).\]
We invoked the logical meaning of \(x \geq 0\), \(x \leq 0\), and \(x = 0\).
Thus we are \emph{not} purely using the theory of TopKAT.
\end{example}

We can use more than just logical implications.
Since our encoding of incorrectness logic is conservative (relationally valid), 
all the proof rules of incorrectness logic will play nicely with algebraic reasoning.
The next example demonstrates the mix of equational reasoning and assignment rule.

\begin{example}[Assignment]
    We have the same program as \Cref{exp: incorrect absolute value}
    with the precondition changed to \(x \geq 0\):
    \[\incorTriple{x > 0}{\comITE{x < 0}{\comSkip}{\comAssign{x}{-x}}}{x < 0}.\]

    Even though the assignment rule from Incorrectness Logic is not propositional, 
    in the sense we use in this thesis,  
    we can use specific inequalities to represent specific instances of these rules. 
    For example, we can use an instance represented by the following incorrectness triple:
\[\incorTriple{x > 0}{\comAssign{x}{-x}}{x < 0},\]
This triple corresponds to the following TopKAT inequality:
\[\top (x > 0) (\comAssign{x}{-x}) \geq (x < 0).\]
With the above inequality, we can derive the incorrectness triple in the example as follow:
\begin{align*}
    & \top (x > 0) ((x < 0) 1 + \overline{(x < 0)} (\comAssign{x}{-x})) \\
    & \geq \top (x > 0) (\overline{(x < 0)} (\comAssign{x}{-x})) 
        & p + q \geq q\\
    & \geq \top (x > 0) (\comAssign{x}{-x}) 
        & (x > 0) \leq \overline{(x < 0)}\\
    & \geq (x < 0) 
        & \text{above inequality}
\end{align*}
\end{example}

Thus, as we can see, even though TopKAT does not contain an assignment axiom,
we can still reason about programs with assignments.

\section{Related Works}

\textbf{Extensions of Kleene algebra and reduction:}
soon after the completeness of Kleene algebra was proven~\cite{Kozen_1994},
it was realized that adding an embedded Boolean algebra can help reasoning
about control structures, such system is referred to as
Kleene algebra with tests (KAT)~\cite{Kozen_Smith_1997,Cohen_Kozen_Smith_1999}.
Later KAT was further extended to reason about failure~\cite{Mamouras_2017},
indicator variables~\cite{Grathwohl_Kozen_Mamouras_2014},
domain~\cite{Desharnais_Möller_Struth_2006}, networks~\cite{Anderson_Foster_Guha_Jeannin_Kozen_Schlesinger_Walker_2014},
and relational reasoning~\cite{Antonopoulos_Koskinen_Le_Nagasamudram_Naumann_Ngo_2022}.
Kleene algebra has also been extended to reason about 
concurrency, as concurrent Kleene algebra~\cite{Hoare_van_Staden_Möller_Struth_Zhu_2016, Kappé_Brunet_Silva_Zanasi_2018}
and concurrent Kleene algebra with observations~\cite{Kappé_Brunet_Silva_Wagemaker_Zanasi_2020}.
Many of these extensions can be seen as Kleene algebra with extra hypotheses~\cite{Cohen_1995,Doumane_Kuperberg_Pous_Pradic_2019}.
Although many hypotheses make the theory undecidable~\cite{Kozen_1996,Kozen_2002,Doumane_Kuperberg_Pous_Pradic_2019},
many useful hypotheses can be eliminated via reduction~\cite{Pous_Rot_Wagemaker_2021}.
Thus, our new perspective on reduction could potentially lead to streamlining of various previous proofs, 
and more general proofs of completeness results.

\textbf{Top element:}
Tarski's relational algebra~\cite{tarski_CalculusRelations_1941} contains the addition, 
mulitiplication, and identity operation of KA;  
in addition, relational algebra also include a top element. 
Hence attempts to incorporat Kleene star into relational algebra 
effectively create a super theory of TopKAT.
Unfortuantly, several attempts at these algebras turn out to be undecidable
because of the presence of intersection and 
converse operations~\cite{andrekaAxiomatizabilityPositiveAlgebras2011, pous_PositiveCalculusRelations_2018}.
With the intersection and converse operators removed, 
top element is proven to be individually useful in Kleene algebra:
for example, Mamouras~\cite{Mamouras_2017} uses the top element to forget program states,
and Antonopoulos et al.~\cite{Antonopoulos_Koskinen_Le_Nagasamudram_Naumann_Ngo_2022} 
uses top to design forward simulation rules for relational verification, 
and claim that relational incorrectness logic~\cite{murray_UnderApproximateRelationalLogic_2020a} 
can be encoded using BiKAT extended with top.
The completeness and decidability of TopKAT was first studied by Zhang et al.~\cite{Zhang_de_Amorim_Gaboardi_2022},
and concluded that TopKAT is not complete with relational models.
Later, Pous et al.~\cite{Pous_Wagemaker_2022,Pous_Wagemaker_2023} showed that 
both TopKA and TopKAT is complete with relational model with one additional axiom: \(p ⊤ p ≥ p\),
and the theory remains PSPACE-complete, like KAT and TopKAT.
In this section, we showed that TopKAT without the additional axiom is complete 
for a specific form of inequalities, namely when top only appears in the front or the end of the term.
Although this form of inequalities seem restrictive, 
they are enough to encode both Hoare and incorrectness logic~\cite{Zhang_de_Amorim_Gaboardi_2022}.

\textbf{Domain in KAT:}
The study of axiomatizing (co)domain in KAT has a long and rich history. 
Domain semiring~\cite{Desharnais_Struth_2011} 
and Kleene algebra with domain~\cite{Desharnais_Möller_Struth_2006}
were two popular yet different axiomatizations of (co)domain in Kleene algebra with tests.
These two axiomitizations turn out to coincide in a large class of semirings~\cite{Fahrenberg_Johansen_Struth_Ziemiánski_2021}.
Various applications for domain in KAT have been discovered, including modeling
program correctness, predicate transformers, temporal logics, 
termination analysis, and many more~\cite{Desharnais_Möller_Struth_2004}.
Many of these applications can even be efficiently automated~\cite{hofner_AutomatedReasoningKleene_2007}.
However, although the free relational model of these theories has been characterized~\cite{mclean_FreeKleeneAlgebras_2020},
the search for general complete interpretation remains unfruitful.
The complexity of these theories was recently shown to be EXPTIME-complete~\cite{Sedlár_2023},
a worse complexity class than PSPACE-complete for TopKAT.
